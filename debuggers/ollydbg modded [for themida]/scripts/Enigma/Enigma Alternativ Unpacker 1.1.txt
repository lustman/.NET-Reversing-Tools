////////////////////////Château-Saint-Martin//////////////////////////////////////////////////////////////
//                                                                      /////////////////////////////////
//  FileName    :  Enigma Alternativ Unpacker 1.1                       ////////////////////////////////
//  Features    :                                                       ///////////////////////////////
//                 This script can unpack almost any protected          //////////////////////////////
//                 ENIGMA file.It does dump the extern VM.              /////////////////////////////
//                 Script is only a "Alternativ"!                       ////////////////////////////
//                                                                      ///////////////////////////
//                 Watch my movies to know how to use this script!      //////////////////////////
//                                                                      /////////////////////////
//                  *************************************************** ////////////////////////
//               ( 1.) Unpacking of ENIGMA 1.90 - 3.130+              * ///////////////////////
//                                                                    * //////////////////////
//               ( 2.) RegSheme Bypass & HWID Changer                 * /////////////////////
//                                                                    * ////////////////////
//               ( 3.) Enigma CheckUp Killer                          * ///////////////////
//                                                                    * //////////////////
//               ( 4.) VirtualMemory Dumper 1.90 - 3.x+ & SC Fixer M1 * /////////////////
//                                                                    * ////////////////
//               ( 5.) UIF Tool Necessary Sometimes!                  * ///////////////
//                                                                    * //////////////
//               ( 6.) Enigma Intern Export & VM Scan + Log           * /////////////
//                                                                    * ////////////
//               ( 7.) Improved Import Emulation Fixer                * ///////////
//                                                                    * //////////
//               ( 8.) Supports Exe & Dll Files         [ dll at EP!] * /////////
//                                                                    * ////////
//                  *************************************************** ///////
//  Environment :  WinXP SP3,OllyDbg V1.10,OllyScript v1.82.6           //////
//                                                                      ///// 
//  Author      :  LCF-AT                                               ////
//  Date        :  2013-22-05 | MAI                                     ///
//                                                                      //
//                                                                     //
///////////////WILLST DU SPAREN,DANN MUßT DU SPAREN!////////////////////
lclr
lc
call VARS
////////////////////////////////////////////////////////////
//
// Just enter below your path to the TitanEngine.dll and save!
////////////////////////////////////////////////////////////
mov TITAN,     "C:\Program Files\Cracker Tools 2.4 By yildo\Debuggers\OllyICE_yildo1\plugin\TitanEngine.dll"
cmp TITAN, 00
je ENTER_YOUR_TITAN_PATH
cmp TITAN, #203E3E456E74657220#, 09
je ENTER_YOUR_TITAN_PATH
call CHECK_TITAN
////////////////////////////////////////////////////////////
// Updates: Version 1.1
// -----------------------------------------
// Added Overlay Scan & Dumper - Enable / Disable it in the user options
// Added Another Enigma Intern Export & VM Scan + Log + Labeling
// Added User IAT Handling OF START & END         [rarly needed]
// Added Better Intern API Scan & Fix Via Table
// Added Better VM Poniter Scan
//
// Helpfully Infos also for lazy fuzzy's! :)
// -----------------------------------------
// If you need to use UIF then redirect the new IAT in the ENIGMA section ONLY if no Outer VM is used!
// Or better you just alloc a new free section and redirect the new IAT there and add the section on your dump!
// Check the end of your IAT there you can find the ENIGMA APIs if used with real names!
// Of course you still have to fix these APIs by yourself in your dump later!
// If you can't bypass the HWID Nag if you press OK or Close [endless-loop] then press the X button on the window!
// If the target has no X [for exit] button then force it manually with a extern tool like winforce!See my video!
// Internal Error or Double-Protection message means in the most cases that you need valid HWID - Name - Key datas!
// If you can't find a logged Enigma API in the enigma_ide.dll then use A|W or Ex at the end!
// Exsample: EP_RegCheckKey or EP_RegCheckKey|A| or EP_RegCheckKey|W| read Enigma help file for more infos!
//
////////////////////////////////////////////////////////////
pause
/*
Below you can see the USER CHOICE.Set to 00 = Off or 01 = On
If you have some valid HWID ID then remove the "-" between the HWID and enter the string into HWID variable
Start the script always from EntryPoint of your target

DUMP_OUTER_VM:
--------------------
You can try to let dump the VM by the script.If you get the new VM sections dumped then add them to your
dumped file.You can add them with the right RVA + PE rebuild or you just add the sections but then you 
need to change the VM Pointer addresses in your dumped file!Also you have to change the ESP Pointer always 
so for this you can use any no more needed section + some bytes for exsample.See video tutorial.

LCF-AT
*/
///////////////////////
USER_SETUP_THE_OPTIONS:
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
mov DUMP_OUTER_VM,     01                 // Set to 01 if you want to let dump the extern outer VM!
mov CRC_PATCH,         00                 // Set to 01 if you want to patch CRCs - Don't use it if you change HWID!
mov HWID_PATCH,        00                 // Set to 01 if you have valid HWID datas!Enter HWID String below!
mov HWID_EASY_BYPASS,  00                 // For basic HWID bypass ONLY!No valid data needed!
mov PRE_CHECKER_PATCH, 01                 // Prevent basic Check-Up of Enigma!Trial,pass,etc!
mov READ_DLL_LOADER,   00                 // Read and log all intern loader EP_XY exports APIs!
mov GET_EP_VM_VALUES,  00                 // Find all VMed EP push API values!Use it if your target used EP APIs in the IAT!
mov HWID, "13EB8AFBB17E67993528EDAFCC9636430C3D77B5"

mov SCAN_DUMP_OVR,     00                 // Set to 01 if you wanna let scan & dump for overlays!
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////
RETURN_CHECK:
gpi EXEFILENAME
mov TESTNAME, $RESULT
len TESTNAME
mov TESTNAMELENGHT, $RESULT
gmi eip, NAME
mov IS_EIP_NAME, $RESULT
scmpi IS_EIP_NAME, "loaddll"
jne NO_LOADDLL_STOP
eval "{SCRIPTNAME} {L2}{LONG} {L1} {L2}Start the script at the EP of your target! {L1}{LINES} \r\n{MY}"
msg $RESULT
setoption
ret
///////////////////////
NO_LOADDLL_STOP:
alloc 1000
mov TESTI, $RESULT
pusha
mov eax, TESTI
mov [TESTI], TESTNAME
add eax, TESTNAMELENGHT
xor edi,edi
///////////////////////
FIND_LINER:
cmp [eax], 5C, 01
je FOUND_LINER
dec eax
inc edi
jmp FIND_LINER
///////////////////////
FOUND_LINER:
inc eax
dec edi
gstr eax, edi
mov REALNAME, $RESULT
mov TARGET_NAME, $RESULT
log ""
eval "Real target name is: {REALNAME}"
log $RESULT, ""
fill TESTI, 1000, 00
mov [TESTI], REALNAME
mov edi, TESTI
xor eax,eax
exec
push edi
call {GetModuleHandleA}
ende
cmp eax, 00
jne GOT_LOADED_BASE
popa
free TESTI
eval "{SCRIPTNAME} {L2}{LONG} {L1} {L2}Can't get the Base of your target! {L1}{LINES} \r\n{MY}"
msg $RESULT
ret
///////////////////////
GOT_LOADED_BASE:
mov MODULEBASE, eax
log MODULEBASE
mov edi, eax
add eax, 3C
mov eax, edi+[eax]
mov ENTRY, edi+[eax+28]
log ENTRY
mov FILEALIG, [eax+38]
cmp [eax+104], FILEALIG
jne NO_NET
cmp [eax+104], 1000
je NO_NET
jb NO_NET
eval "{SCRIPTNAME} {L2}{LONG} {L1} {L2}Sorry,NetFrameWork targets are not supported! {L1}{LINES} \r\n{MY}"
msg $RESULT
ret
///////////////////////
NO_NET:
cmp eip, ENTRY
je STOP_IS_EP
mov TLS, edi+[eax+0C0]
mov TLS_WO, [TLS+0C]
mov TLS_WO, [TLS_WO]
cmp TLS_WO, 00
je NO_TLS_CB_FOUND
popa
bphws TLS_WO
esto
bphwc
cmt eip, "TLS"
jmp STOP_IS_EP_TLS
///////////////////////
NO_TLS_CB_FOUND:
popa
bphws ENTRY
esto
bphwc
///////////////////////
STOP_IS_EP:
popa
///////////////////////
STOP_IS_EP_TLS:
mov EP, eip
jmp NO_SYSTEM_STOP
///////////////////////
NO_SYSTEM_STOP:
gmi eip, PATH
mov PATH, $RESULT
GPI CURRENTDIR
mov CURRENTDIR, $RESULT
len CURRENTDIR
mov CURRENTDIR_LENGHT, $RESULT
pusha
mov eax, MODULEBASE
jmp EXE_FILE
//----------------------- weg
alloc 1000
mov BAK, $RESULT
mov [BAK], PATH
pusha
mov eax, BAK
add eax, CURRENTDIR_LENGHT
find eax, #00#
mov ecx, $RESULT
sub ecx, eax
readstr [eax], ecx
mov TARGET_NAME, $RESULT
buf TARGET_NAME
str TARGET_NAME
log TARGET_NAME, ""
exec
pushad
push eax
call {GetModuleHandleA}
ende
cmp eax, 00
jne GOT_EXE_BASE
popa
eval "{SCRIPTNAME} {L2}{LONG} {L1} {L2}Can't get the ModuleBase of your target! {L1}{LINES} \r\n{MY}"
msg $RESULT
pause
ret
///////////////////////
GOT_EXE_BASE:
refresh eip
gmi eax, NAME
scmp $RESULT, "loaddll"
jne EXE_FILE
bphwc
eval "{SCRIPTNAME} {L2}{LONG} {L1} {L2}Load file at EP and then start the script! {L1}{LINES} \r\n{MY}"
msg $RESULT
pause
ret
//----------------------- weg
///////////////////////
EXE_FILE:
mov edi, eax
add eax, 3C
mov eax, edi+[eax]
mov ENTRY, edi+[eax+28]
mov IMAGESIZE, edi+[eax+50]
eval "SectionEnd: {IMAGESIZE}"
log $RESULT, ""
mov TLS, edi+[eax+0C0]
cmp TLS, edi
jne TLS_PRESENT
log "No TLS Present"
jmp OVER_TLS
///////////////////////
TLS_PRESENT:
log TLS
mov TLS_CB, TLS+0C
log TLS_CB
mov TLS_CB_IN, [TLS_CB]
log TLS_CB_IN
///////////////////////
OVER_TLS:
log ""
mov SECTIONS, [eax+06], 02
mov esi, eax+0F8
mov edi, 28
mov ebp, SECTIONS
mov ecx, edi
mul edi, SECTIONS
add edi, esi
sub edi, 28
mov LASTSEC, [edi+0C]
add LASTSEC, MODULEBASE
sub edi, 28
mov ENIGMASEC, [edi+0C]
add ENIGMASEC, MODULEBASE
mov PE_START, eax
mov ENDSEC, LASTSEC
gmemi LASTSEC, MEMORYSIZE
add ENDSEC, $RESULT
exec
popad
ende
popa
cmp SCAN_DUMP_OVR, 01
jne AFTER_OVERLAY
call SCAN_DUMP_OVERLAY
///////////////////////
AFTER_OVERLAY:
alloc 1000
mov TEMP_SEC, $RESULT
mov [TEMP_SEC], #606A006A00E80837AAA96190#
eval "call {GetProcAddress}"
asm TEMP_SEC+05, $RESULT
mov eip, TEMP_SEC
bp eip+0B
///////////////////////
GPA_AGAIN:
bp GetProcAddress
run
bc eip
rtr
cmp eip, GetProcAddress
je GPA_AGAIN
mov GetProcAddress_RET, eip
run
bc
mov eip, EP
free TEMP_SEC
///////////////////////
CHECK_ENTRY:
cmp eip, ENTRY
je SET_GPA_HWBP
bphws ENTRY
esto
bphwc
jmp CHECK_ENTRY
///////////////////////
SET_GPA_HWBP:
bphws GetProcAddress_RET
esto
bphwc
cmp [esi], #4D5A# ,02
je IS_ENIGMASEC
cmp [edi], #4D5A# ,02
je IS_ENIGMASEC
pause
pause
ret
///////////////////////
IS_ENIGMASEC:
bphwc
cmp esi, ENIGMASEC
je ENIGMASEC_USED
cmp edi, ENIGMASEC
je ENIGMASEC_USED
cmp esi, LASTSEC
je ENIGMASEC_LASTSEC
cmp edi, LASTSEC
je ENIGMASEC_LASTSEC
pause
pause
ret
///////////////////////
ENIGMASEC_LASTSEC:
log ""
eval "Enigmasection is: {LASTSEC}"
log $RESULT, ""
mov IS_ENIGMA, LASTSEC
jmp AFTER_ENIGMA_SEC_CHECK
///////////////////////
ENIGMASEC_USED:
log ""
eval "Enigmasection is: {ENIGMASEC}"
log $RESULT, ""
mov IS_ENIGMA, ENIGMASEC
jmp AFTER_ENIGMA_SEC_CHECK
///////////////////////
AFTER_ENIGMA_SEC_CHECK:
pusha
mov eax, ENIGMASEC
///////////////////////
FIND_VERSION:
find eax, #454E49474D41#
cmp $RESULT, 00
je ENIGMA_STRING_NOT_FOUND
mov eax, $RESULT+06
cmp [eax], 00 ,02
je FIND_VERSION
mov ecx, 00
mov ecx, [eax]
cmp cl, 04
ja FIND_VERSION
mov V1, cl
shr ecx, 08
mov V2, cl
and ecx, 000000FF
// shr ecx, 04
itoa V1, 10.
mov  V1, $RESULT
itoa V2, 10.
mov  V2, $RESULT
cmp cl, 0A
jb VERSION_ZERO
eval "ENIGMA VERSION | {V1}.{V2} - Static Scan!"
log  $RESULT, ""
jmp VERSION_END
///////////////////////
VERSION_ZERO:
eval "ENIGMA VERSION | {V1}.0{V2} - Static Scan!"
log  $RESULT, ""
///////////////////////
VERSION_END:
popa
atoi V1
mov V1, $RESULT
atoi V2
mov V2, $RESULT
jmp ANTI_PLUG_CHECK
///////////////////////
ENIGMA_STRING_NOT_FOUND:
mov eax, LASTSEC
///////////////////////
FIND_VERSION_2:
find eax, #454E49474D41#
cmp $RESULT, 00
je ENIGMA_STRING_NOT_FOUND_2
mov eax, $RESULT+06
cmp [eax], 00 ,02
je FIND_VERSION_2
mov ecx, 00
mov ecx, [eax]
cmp cl, 04
ja FIND_VERSION_2
mov V1, cl
shr ecx, 08
mov V2, cl
and ecx, 000000FF
// shr ecx, 04
itoa V1, 10.
mov  V1, $RESULT
itoa V2, 10.
mov  V2, $RESULT
cmp cl, 0A
jb VERSION_ZERO_2
eval "ENIGMA VERSION | {V1}.{V2} - Static Scan!"
log  $RESULT, ""
jmp VERSION_END_2
///////////////////////
VERSION_ZERO_2:
eval "ENIGMA VERSION | {V1}.0{V2} -  Static Scan!"
log  $RESULT, ""
///////////////////////
VERSION_END_2:
popa
atoi V1
mov V1, $RESULT
atoi V2
mov V2, $RESULT
jmp ANTI_PLUG_CHECK
///////////////////////
ENIGMA_STRING_NOT_FOUND_2:
popa
log ""
log "Found no Enigma version!"
jmp NO_ENIGMA_VERSION_FOUND
///////////////////////
ANTI_PLUG_CHECK:
cmp V1, 00
je NO_ENIGMA_VERSION_FOUND
pusha
mov eax, 00
mov ecx, 00
mov eax, V1
mov ecx, V2
cmp al, 02
je HIGER_VERSION
ja HIGER_VERSION
cmp cl, 90
je HIGER_VERSION
ja HIGER_VERSION
popa
eval "{SCRIPTNAME} {L2}{LONG} {L1} {L2}Enigma version is lower than 1.90! {L1}Script will only work for version 1.90 and higher! {L1}For older versions you can use my other Enigma script! {L1}{LINES} \r\n{MY}"
msg $RESULT
pause
ret
jmp NO_ENIGMA_VERSION_FOUND
///////////////////////
HIGER_VERSION:
popa
///////////////////////
NO_ENIGMA_VERSION_FOUND:
mov BAK, eip
call EXPORT_VM_CHECK
mov eip, BAK
///////////////////////
NO_ENIGMA_VERSION_FOUND_2:
find ENIGMASEC, #456E69676D615F506C7567696E5F4F6E496E6974#
cmp $RESULT, 00
je FIND_NEW_CRC
mov ANTI_PLUG, $RESULT
mov [ANTI_PLUG], 00
log ""
eval "Found and Patched Anti Plug at: {ANTI_PLUG}"
log $RESULT, ""
jmp NO_ENIGMA_VERSION_FOUND_2
///////////////////////
FIND_NEW_CRC:
find ENIGMASEC, #83C8FF8BDA4B85DB7C??#
cmp $RESULT, 00
je NO_CRC_FOUND
mov CRC_1, $RESULT
add CRC_1, 08
eval "1 New CRC found at: {CRC_1}"
log $RESULT, ""
find CRC_1, #83C8FF8BDA4B85DB7C??#
cmp $RESULT, 00
je CRC_OVER
mov CRC_2, $RESULT
add CRC_2, 08
eval "1 New CRC found at: {CRC_2}"
log $RESULT, ""
jmp CRC_OVER
///////////////////////
NO_CRC_FOUND:
///////////////////////
CRC_OVER:
cmp CRC_PATCH, 00
je DO_NOT_PATCH_CRC
cmp CRC_1, 00
je DO_NOT_PATCH_CRC
mov [CRC_1], EB, 01
log "CRC_1 was patched"
cmp CRC_2, 00
je DO_NOT_PATCH_CRC
mov [CRC_2], EB, 01
log "CRC_2 was patched"
///////////////////////
DO_NOT_PATCH_CRC:
find ENIGMASEC, #8B08C601E9#
cmp $RESULT, 00
je NO_VM_OEP_FOUND
mov VMOEP, $RESULT
find VMOEP, #C601FFFF00#
cmp $RESULT, 00
je NO_VM_OEP_FOUND
mov VMOEP, $RESULT
log ""
log "VM OEP SIGN FOUND!"
///////////////////////
NO_VM_OEP_FOUND:
// bphws VirtualAlloc
// esto
// esto
// xor eax, eax
bphwc
cmp GET_EP_VM_VALUES, 01
je ROUTINE_DONE
call READ_PUSH_VALUES
///////////////////////
ROUTINE_DONE:
cmp INT_VERSION, 00
je NO_INT_VERSION
cmp IN_VMER, 00
je NO_INT_VERSION
mov BAKA, eip
alloc 1000
mov ESV, $RESULT
eval "call {INT_VERSION}"
asm ESV, $RESULT
bphws ESV+05
mov eip, ESV
pusha
esto
bphwc
mov eip, BAKA
mov ecx, eax
and ecx, 000000FF
mov V2, cl
shr eax, 08
mov V1, al
itoa V1, 10.
mov  V1, $RESULT
itoa V2, 10.
mov  V2, $RESULT
cmp cl, 0A
jb VERSION_ZERO_2_A
popa
free ESV
eval "ENIGMA VERSION | {V1}.{V2} - Intern EP Scan = Real Version!"
log $RESULT, ""
jmp NO_INT_VERSION
///////////////////////
VERSION_ZERO_2_A:
popa
free ESV
eval "ENIGMA VERSION | {V1}.0{V2} - Intern EP Scan = Real Version!"
log $RESULT, ""
jmp NO_INT_VERSION
///////////////////////
NO_INT_VERSION:
find ENIGMASEC, #85C00F95C08B??????????8B??8?#
cmp $RESULT, 00
je NP_HWID_BASIC_FOUND
mov REG1, $RESULT+02
find REG1, #85C00F95C08B??????????8B??8?#
mov REG2, $RESULT+02
gci REG1, COMMAND
mov REG1_COM, $RESULT
gci REG2, COMMAND
mov REG2_COM, $RESULT
log ""
log "Possible used RegSheme found!"
log ""
eval "Address: {REG1} - {REG1_COM}"
log $RESULT, ""
eval "Address: {REG2} - {REG2_COM}"
log $RESULT, ""
log ""
///////////////////////
NP_HWID_BASIC_FOUND:
find ENIGMASEC, #89431?83C31C4E75??5F5E5BC3#  // 75B7
cmp $RESULT, 00
jne FOUND_API_TABLE
pause
pause
ret
///////////////////////
FOUND_API_TABLE:
mov IAT_TABLE_1, $RESULT
mov [IAT_TABLE_1+02], 14, 01
find ENIGMASEC, #33D2????????????74??????????????74??????????????74#
cmp $RESULT, 00
je NO_MJ_FOUND
mov MJ, $RESULT
mov [MJ], #33D2B801000000C3#
log ""
eval "MJ found and patched at: {MJ}"
log $RESULT, ""
///////////////////////
NO_MJ_FOUND:
find ENIGMASEC, #8D047F8B55FC8B4DF0894C820447FF4DD0#
cmp $RESULT, 00
je NO_QUCIK_RD_FOUND
mov QUICK, $RESULT
///////////////////////
NO_QUCIK_RD_FOUND:
find ENIGMASEC, #83BC243003000000740233C081C4380300005BC3#
cmp $RESULT, 00
jne FOUND_API_CATCHER
find ENIGMASEC, #8B45F883F8FF750233C059595DC3#
cmp $RESULT, 00
jne FOUND_API_CATCHER_NEW
cmp QUICK, 00
jne SET_HWBP
cmp MJ, 00
jne SET_HWBP
pause
pause
ret
///////////////////////
FOUND_API_CATCHER_NEW:
mov CATCH_1, $RESULT
mov [CATCH_1+06], 9090, 02
jmp SET_HWBP
///////////////////////
FOUND_API_CATCHER:
mov CATCH_1, $RESULT
mov [CATCH_1+08], 9090, 02
jmp SET_HWBP
///////////////////////
SET_HWBP:
///////////////////////
NO_QUCIK_RD:
find ENIGMASEC, #C602824633C08A062DE00000008901BF020000008BC75F5E5B5DC20C00#
cmp $RESULT, 00
jne FOUND_API_CATCHER_2
cmp QUICK, 00
jne SINGLE_SET
cmp MJ, 00
jne SINGLE_SET
pause
pause
ret
///////////////////////
FOUND_API_CATCHER_2:
mov CATCH_2, $RESULT
mov [CATCH_2+14], #33C0#, 02
///////////////////////
SINGLE_SET:
///////////////////////
FIND_HWID_PLACE:
cmp HWID_PATCH, 00
je NO_HWID_PATCH
find ENIGMASEC, #66D3E0660BD8#
cmp $RESULT, 00
je HWID_NOT_FOUND
mov HWID_WO, $RESULT
add HWID_WO, 08
find HWID_WO, #66D3E0660BD8#
cmp $RESULT, 00
je HWID_NOT_FOUND
mov HWID_WO, $RESULT
find HWID_WO, #EB238B07#
cmp $RESULT, 00
je HWID_NOT_FOUND
mov HWID_WO, $RESULT
sub HWID_WO, 25
log HWID_WO
bphws HWID_WO
mov HWID_IS_SET, 01
jmp PRE_EXIT_CHECK
///////////////////////
HWID_NOT_FOUND:
log "Found no HWID place!"
jmp PRE_EXIT_CHECK
///////////////////////
NO_HWID_PATCH:
log "HWID check is disbaled by user!"
///////////////////////
PRE_EXIT_CHECK:
find ENIGMASEC, #81FB2C0100007?#
cmp $RESULT, 00
je NO_PRE_CHECKER_FOUND
mov PRE_CHECKER, $RESULT-33
find PRE_CHECKER, #558BEC#
cmp $RESULT, 00
jne FOUND_PRE_TOP
pause
pause
ret
///////////////////////
FOUND_PRE_TOP:
mov PRE_CHECKER, $RESULT
log PRE_CHECKER
///////////////////////
NO_PRE_CHECKER_FOUND:
///////////////////////
PRE_EXIT_CHECK:
cmp PRE_CHECKER_PATCH, 00
je NO_PRE_CHECKER_BYPASS
cmp PRE_CHECKER, 00
je NO_PRE_CHECKER_BYPASS
cmp HWID_IS_SET, 01
jne SET_PRE_CHECKER
///////////////////////
SET_PRE_CHECKER:
bphws PRE_CHECKER
///////////////////////
NO_PRE_CHECKER_BYPASS:
cmp HWID_IS_SET, 01
je RUN_NOW
cmp HWID_EASY_BYPASS, 00
je RUN_NOW
mov [REG1-02], FE, 01
mov [REG2-02], FE, 01
log "HWID EASY BYPASS was patched!"
// bp REG1
// bp REG2
// bpgoto REG1, HWID_SIMPLE
// bpgoto REG2, HWID_SIMPLE
jmp RUN_NOW
///////////////////////
HWID_SIMPLE:
bc
mov eax, 01
preop eip
mov eip, $RESULT
jmp RUN_NOW
///////////////////////
RUN_NOW:
cmp VMOEP, 00
jne SET_VM_OEP
ask "Found no VM OEP! - Enter a OEP address manually!"
cmp $RESULT, 00
je RUN_NOW
mov OEP, $RESULT
bphws OEP
log "OEP entered by user!"
cmp QUICK, 00
je RUN_NOW_2
cmp MJ, 00
jne RUN_NOW_2
bphws QUICK
jmp RUN_NOW_2
///////////////////////
SET_VM_OEP:
bphws VMOEP
mov VMOEP_SET, 01
cmp QUICK, 00
je RUN_NOW_2
cmp MJ, 00
jne RUN_NOW_2
bphws QUICK
///////////////////////
RUN_NOW_2:
esto
///////////////////////
RUN_LOOP:
cmp eip, PRE_CHECKER
jne LAA
mov eip, [esp]
add esp, 04
esto
jmp RUN_LOOP
///////////////////////
LAA:
cmp eip, HWID_WO
jne NEXT_ONE
mov store, edi
mov store, [store]
mov [store], HWID
esto
jmp RUN_LOOP
///////////////////////
NEXT_ONE:
cmp eip, QUICK
jne VMLER
bphwc eip
add eip, 17
mov QUICK_PATCHED, 01
jmp RUN_NOW_2
///////////////////////
VMLER:
cmp eip, VMOEP
je NEXT
cmp eip, OEP
je LOG_OEP
///////////////////////
RUNO:
JMP RUN_LOOP
///////////////////////
NEXT:
bphwc
mov VMOEPBAK, eip
///////////////////////
VM_OEP_LOOP:
mov VMOEP, ecx
rtr
bphws VMOEP
bphws VMOEPBAK
esto
bphwc
cmp eip, VMOEPBAK
je VM_OEP_LOOP
gmemi eax, MEMORYBASE
cmp $RESULT, 00
jne VM_OEP_SAME
mov tmp, eip
mov tmp2, eip
sub tmp, 140
///////////////////////
FIND_OEP_POINTER:
find tmp, #B8#
cmp $RESULT, 00
jne OEP_POINTER
pause
pause
ret
///////////////////////
OEP_POINTER:
mov tmp, $RESULT
cmp tmp, tmp2
jb LOWER_IT
mov tmp, eip
mov tmp2, eip
sub tmp, 140
mov MAK_LOW, 01
jmp FIND_OEP_POINTER
pause
pause
ret
///////////////////////
LOWER_IT:
pusha
mov eax, [tmp+01]
mov ecx, MODULEBASE
mov edx, IMAGESIZE
cmp MAK_LOW, 01
jne NORMAL_CHECKI
gmemi eax, MEMORYBASE
cmp $RESULT, 00
je NORMAL_CHECKI
mov tmp, eax
popa
jmp OEP_POINTER_FOUND
///////////////////////
NORMAL_CHECKI:
cmp eax, ecx
jb WRONG_POINTER
cmp eax, edx
ja WRONG_POINTER
mov tmp, eax
popa
jmp OEP_POINTER_FOUND
///////////////////////
WRONG_POINTER:
popa
add tmp, 05
jmp FIND_OEP_POINTER
///////////////////////
OEP_POINTER_FOUND:
mov eax, tmp
///////////////////////
VM_OEP_SAME:
sti
jmp LOG_OEP
///////////////////////
LOG_OEP:
bphwc
pusha
mov eax, MODULEBASE
gmemi eax, MEMORYSIZE
add eax, $RESULT
mov CODESECTION, eax
mov edi, eip
cmp edi, eax
jb MEM_OEP
mov eax, LASTSEC
gmemi eax, MEMORYSIZE
add eax, $RESULT
mov ENDSEC, eax
cmp edi, eax
ja MEM_OEP
log "OEP is inside of the target!"
popa
jmp CODE_OEP
///////////////////////
MEM_OEP:
popa
cmt eip, "<<<< VM OEP - Copy to main target!Use MultiASM!"
log "OEP is outside of the target!"
log "Copy OEP code from eip to main target!"
eval "{SCRIPTNAME} {L2}{LONG} {L1} {L2}Copy OEP code from eip to main target! {L1}Set eip to new OEP and then resume the script! {L1}{LINES} \r\n{MY}"
msg $RESULT
pause
mov OEP, eip
///////////////////////
CODE_OEP:
cmt eip, "OEP"
mov OEP, eip
pusha
mov eax, CODESECTION
///////////////////////
FIND_API_COMMANDS:
find eax, #FF15#
cmp $RESULT, 00
je NO_CALLS
mov eax, $RESULT+02
mov ecx, $RESULT
mov ecx, [ecx+02]
mov edx, [ecx]
gn edx
cmp $RESULT_2, 00
je FIND_API_COMMANDS
mov POS_MEMIAT, ecx
cmp ecx, MODULEBASE
jb APIS_OUTSIDE
cmp ecx, ENDSEC
ja APIS_OUTSIDE
mov API_INTO, ecx
popa
log ""
log "APIs located in main target!"
jmp WRITE_IAT_BACK
///////////////////////
APIS_OUTSIDE:
popa
log "APIs located outside in memory!"
log "Use UIF tool and then resume the script!"
log ""
find ENIGMASEC, #BF????????BB????????8B35????????803B0074??8B#
cmp $RESULT, 00
je NO_IIE_FOUND
log ""
log "Attention!If your target is a higher Enigma version 3.90+ then it can use a Improved Import Emulation!!!"
log "Analyse the codesection and serach for all intermodular calls!"
log "Now check the commands for not visible APIs and if you find then follow!"
log "Improved Import Emulation = call to LEA ESP,DWORD PTR SS:[ESP-4] or PUSH Value call to VM!"
log "If they used then press YES if not then press NO!Enter the IAT data manually from the first til last = size!"
eval "{SCRIPTNAME} {L2}{LONG} {L1} {L2}APIs located outside in memory! {L1}Use UIF tool and then resume the script! {L1}{LINES} \r\n{MY}"
msg $RESULT
eval "{SCRIPTNAME} {L2}{LONG} {L1} {L2}Attention!If your target is a higher Enigma version 3.90+ then it can use a Improved Import Emulation!!! {L1}Analyse the codesection and serach for all intermodular calls! {L1}Now check the commands for not visible APIs and if you find then follow! {L1}Improved Import Emulation = call to LEA ESP,DWORD PTR SS:[ESP-4] or PUSH Value call to VM! {L1}If they used then press YES if not then press NO!Enter the IAT data manually from the first til last = size! {L1}{LINES} \r\n{MY}" 
msgyn $RESULT
cmp $RESULT, 01
jne NO_IIE_FOUND
mov IIE_YES, 01
call NEXT_2
log ""
log "Found & Fixed Improved Import Emulation APIs!"
eval "{SCRIPTNAME} {L2}{LONG} {L1} {L2}Found & Fixed Improved Import Emulation APIs! {L1}Now you can start the UIF tool and after this just resume the script! {L1}{LINES} \r\n{MY}"
msg $RESULT
jmp NO_IIE_FOUND
///////////////////////
NO_IIE_FOUND:
gmemi POS_MEMIAT, MEMORYBASE
mov POS_MEMIAT, $RESULT
gmemi POS_MEMIAT, MEMORYSIZE
mov POS_MEMSIZE, $RESULT-10
mov IAT,      POS_MEMIAT
mov IAT_2,    POS_MEMIAT
mov I_SIZE,   POS_MEMSIZE
mov I_SIZE_2, POS_MEMSIZE
eval "{SCRIPTNAME} {L2}{LONG} {L1} {L2}APIs located outside in memory! {L1}Use UIF tool soon and then resume the script! {L1}{LINES} \r\n{MY}"
msg $RESULT
///////////////////////
NORMAL_PAUSE:
log ""
log "---------- UIF DATA ----------"
log ""
gpi PROCESSID
mov PID, $RESULT
log $RESULT, "PROCESSID:   "
log CODESECTION
gmemi CODESECTION, MEMORYSIZE
mov NEXTSECTION, $RESULT
add NEXTSECTION, CODESECTION
log NEXTSECTION, "NEXTSECTION: "
log ""
log PID, ""
log CODESECTION, ""
log NEXTSECTION, ""
log "------------------------------"
mov NEWWAY, 01
call IAT_LOG
eval "{SCRIPTNAME} {L2}{LONG} {L1} {L2}Now start the UIF tool! {L1}Use UIF tool and then resume the script! {L1}{LINES} \r\n{MY}"
msg $RESULT
pause
mov NEWWAY, 02
jmp WRITE_IAT_BACK
///////////////////////
NO_CALLS:
mov eax, CODESECTION
///////////////////////
FIND_API_COMMANDS_2:
find eax, #FF25#
cmp $RESULT, 00
je NO_JUMPS
mov eax, $RESULT+02
mov ecx, $RESULT
mov ecx, [ecx+02]
mov edx, [ecx]
gn edx
cmp $RESULT_2, 00
je FIND_API_COMMANDS_2
mov POS_MEMIAT, ecx
cmp ecx, MODULEBASE
jb APIS_OUTSIDE
cmp ecx, ENDSEC
ja APIS_OUTSIDE
mov API_INTO, ecx
popa
log ""
log "APIs located in main target!"
jmp WRITE_IAT_BACK
///////////////////////
NO_JUMPS:
popa
log ""
log "Found no valid API call or Jump commands!"
log "Maybe your file used a double protection!"
log "Or you need some valid bypass datas!"
log "HWID | Name | KEy to decryt!"
eval "{SCRIPTNAME} {L2}{LONG} {L1} {L2}Found no valid API call or Jump commands! {L1}Maybe your file used a double protection! {L1}Or you need some valid bypass datas! {L1}{LINES} \r\n{MY}"
msg $RESULT
pause
pause
ret
///////////////////////
WRITE_IAT_BACK:
cmp API_INTO, 00
je ASK_FOR_DATA
pusha
gmemi API_INTO, MEMORYBASE
mov edi, $RESULT
mov eax, API_INTO
mov ecx, API_INTO
//-----------------------
mov edx, ENIGMASEC
//-----------------------
///////////////////////
API_LOOP:
gn [eax]
cmp $RESULT_2, 00
je INSIDE_CHECK
sub eax, 04
jmp API_LOOP
///////////////////////
INSIDE_CHECK:
cmp eax, edi
je FINA
jb FINA
gn [eax-04]
cmp $RESULT_2, 00
jne IS_SOME
gn [eax-08]
cmp $RESULT_2, 00
jne IS_SOME
gn [eax-0C]
cmp $RESULT_2, 00
jne IS_SOME
gn [eax-10]
cmp $RESULT_2, 00
jne IS_SOME
gn [eax-14]
cmp $RESULT_2, 00
jne IS_SOME
cmp [eax-04],  00
jne IS_SOME
cmp [eax-08],  00
jne IS_SOME
cmp [eax-0C],  00
jne IS_SOME
///////////////////////
FINA:
gmemi [eax], MEMORYBASE
cmp $RESULT, edx
jne ADD_ANOTHER
cmp [[eax]], E9 , 01
jne ADD_ANOTHER
jmp API_LOOP_2
///////////////////////
ADD_ANOTHER:
add eax, 04
jmp API_LOOP_2
///////////////////////
IS_SOME:
sub eax, 04
jmp API_LOOP
///////////////////////
API_LOOP_2:
gn [ecx]
cmp $RESULT_2, 00
je INSIDE_CHECK_2
add ecx, 04
jmp API_LOOP_2
///////////////////////
INSIDE_CHECK_2:
gn [ecx+04]
cmp $RESULT_2, 00
jne IS_SOME_2
gn [ecx+08]
cmp $RESULT_2, 00
jne IS_SOME_2
gn [ecx+0C]
cmp $RESULT_2, 00
jne IS_SOME_2
gn [ecx+10]
cmp $RESULT_2, 00
jne IS_SOME_2
gn [ecx+14]
cmp $RESULT_2, 00
jne IS_SOME_2
cmp [ecx+04],  00
jne IS_SOME_2A
cmp [ecx+08],  00
jne IS_SOME_2B
cmp [ecx+0C],  00
jne IS_SOME_2C
jmp API_LOOP_END
///////////////////////
IS_SOME_2A:
cmp [[ecx+04]], E9 , 01
je IS_SOME_2
jmp API_LOOP_END
///////////////////////
IS_SOME_2B:
cmp [[ecx+08]], E9 , 01
je IS_SOME_2
jmp API_LOOP_END
///////////////////////
IS_SOME_2C:
cmp [[ecx+0C]], E9 , 01
je IS_SOME_2
jmp API_LOOP_END
///////////////////////
IS_SOME_2:
add ecx, 04
jmp API_LOOP_2
///////////////////////
API_LOOP_END:
mov IAT,   eax
mov IAT_2, eax
sub ecx, eax
mov I_SIZE,   ecx
mov I_SIZE_2, ecx
log ""
log IAT,  ""
log I_SIZE, ""
log ""
eval "{SCRIPTNAME} {L2}{LONG} {L1} {L2}Attention! {L1}IAT START: {eax} {L1}IAT SIZE : {ecx} {L1}If this is >> NOT << correct then enter the IAT START & END addresses manually! {L1}Press >> YES << if the found IAT data are ok or >> NO << if you want to change it! {L1}{LINES} \r\n{MY}"
msgyn $RESULT
popa
cmp $RESULT, 01
je IAT_LOG
///////////////////////
ASK_FOR_USER_IAT:
ask "Enter your found IAT START address with 8 digits!"
cmp $RESULT, -1
je ASK_FOR_USER_IAT
cmp $RESULT, 00
je ASK_FOR_USER_IAT
mov IAT,   $RESULT
mov IAT_2, $RESULT
gmemi IAT, MEMORYBASE
cmp $RESULT, 00
je ASK_FOR_USER_IAT
///////////////////////
ASK_FOR_USER_IAT_END:
ask "Enter your found IAT END address with 8 digits!"
cmp $RESULT, -1
je ASK_FOR_USER_IAT_END
cmp $RESULT, 00
je ASK_FOR_USER_IAT_END
mov I_SIZE,     $RESULT
mov I_SIZE_2,   $RESULT
gmemi IAT, MEMORYBASE
cmp $RESULT, 00
je ASK_FOR_USER_IAT_END
sub I_SIZE, IAT
add I_SIZE, 04
mov I_SIZE_2, I_SIZE
eval "{SCRIPTNAME} {L2}{LONG} {L1} {L2}New entered IAT START & SIZE by User! {L1}IAT START: {IAT} {L1}IAT SIZE : {I_SIZE} {L1}I will use this datas now for the table scan! {L1}{LINES} \r\n{MY}"
msg $RESULT
jmp IAT_LOG
///////////////////////
ASK_FOR_DATA:
ask "Enter New IAT start address after using UIF!"
mov IAT,   $RESULT
mov IAT_2, $RESULT
ask "Enter New IAT size = last address + 04 bytes!"
mov I_SIZE, $RESULT
mov I_SIZE_2, $RESULT
jmp IAT_LOG
///////////////////////
IAT_LOG:
pusha
log ""
log "---------- IAT DATA ----------"
log ""
mov eax, IAT
add IAT, I_SIZE
eval "IATSTART VA: {IAT_2}"
log $RESULT, ""
eval "IATEND   VA: {IAT}"
log $RESULT, ""
eval "IAT SIZE   : {I_SIZE}"
log $RESULT, ""
log ""
log IAT_2, ""
log IAT, ""
log I_SIZE, ""
log "------------------------------"
log ""
sub IAT, I_SIZE
popa
///////////////////////
IAT_TABLE_READER:
cmp NEWWAY, 02
je NEW_ENIGMA_SCAN_HERE
find ENIGMASEC, #BE????????BB????????803B0074??8B4304#
cmp $RESULT, 00
je NO_IAT_RD_FOUND
mov IAT_RD, $RESULT
find IAT_RD, #83C3??4E75#
cmp $RESULT, 00
jne TWO_SIGN_FOUND
pause
pause
ret
///////////////////////
TWO_SIGN_FOUND:
mov TWO_S, $RESULT
// cmp [TWO_S+02], 20 ,01
// je IAT_RD_FOUND
//---------------------------
mov DIS_COUNT, [TWO_S+02], 01
mov D_TEST,    [IAT_RD+06]
mov D_TEST,    [D_TEST+04]
cmp [D_TEST],  6E72656B
je IAT_RD_FOUND
scmpi [D_TEST], "kernel32", 08
je IAT_RD_FOUND
//---------------------------
add IAT_RD, 10
find IAT_RD, #BE????????BB????????803B0074??8B4304#
cmp $RESULT, 00
jne FOUND_OLD_STYLE
log ""
log "Found No Second TABLE / Old-Style!"
log ""
find ENIGMASEC, #B?????????BB????????8???????????803B0074??8B#
cmp $RESULT, 00
je NO_IAT_RD_FOUND
mov NEW_TABLE_STYLE, 01
mov IAT_RD, $RESULT
find IAT_RD, #83C3??4?75#
cmp $RESULT, 00
jne TWO_SIGN_FOUND_2
pause
pause
ret
///////////////////////
FOUND_OLD_STYLE:
mov IAT_RD, $RESULT
find IAT_RD, #83C3??4E75#
cmp $RESULT, 00
jne TWO_SIGN_FOUND_2
pause
pause
ret
///////////////////////
TWO_SIGN_FOUND_2:
mov TWO_S, $RESULT
//---------------------------
mov DIS_COUNT, [TWO_S+02], 01
mov D_TEST,    [IAT_RD+06]
mov D_TEST,    [D_TEST+04]
cmp [D_TEST],  6E72656B
je IAT_RD_FOUND
scmpi [D_TEST], "kernel32", 08
je IAT_RD_FOUND

mov D_TEST,    [IAT_RD+06]
cmp [D_TEST+08], GetModuleHandleA
je IAT_RD_FOUND
//---------------------------
// cmp [TWO_S+02], 20 ,01
// je IAT_RD_FOUND
pause
pause
ret
///////////////////////
IAT_RD_FOUND:
// ask "Enter IAT size"
// mov I_SIZE, $RESULT
div I_SIZE_2, 04
mov IAT_READ, [IAT_RD+06]
mov I_COUNT,  [IAT_RD+01]
mov OEP, eip
alloc 1000
mov P_SEC, $RESULT
mov [P_SEC], #60BBAAAAAAAABD1B00000009ED743F8B4314BFBBBBBBBBB9FC010000F2AF74064D83C320EBE5FF7304E87CAA06A909C074EEFF730C50E880BB17BA09C074E139431474058947FCEBD78B4310EBF6619090# 
mov [P_SEC+02], IAT_READ
mov [P_SEC+13], IAT_2
mov [P_SEC+07], I_COUNT
mov [P_SEC+18], I_SIZE_2
//---------------------------
mov [P_SEC+23], DIS_COUNT, 01
//---------------------------
cmp NEW_TABLE_STYLE, 01
jne BYPASS_NEW_STYLE
mov [P_SEC+11], 0C, 01
///////////////////////
BYPASS_NEW_STYLE:
pusha
alloc 1000
mov ZAPPA, $RESULT
mov [ZAPPA], "msvbvm60.dll"
mov edi, ZAPPA
xor eax, eax
exec
push edi
call {GetModuleHandleA}
ende
cmp eax, 00
popa
je NO_VB_TARGET
gpa "ThunRTMain", "msvbvm60.dll"
mov ThunRTMain,    $RESULT
pusha
mov eax, IAT_READ
mov ecx, I_COUNT
dec ecx
mov edx, DIS_COUNT
mul ecx, edx
add eax, ecx
cmp NEW_TABLE_STYLE, 01
je FILL_LOWER
mov [eax+10], ThunRTMain
///////////////////////
FILL_LOWER:
mov [eax+0C], ThunRTMain
popa
log ""
log "Target seems to be VB compiled!"
log "ThunRTMain API was filled into table!"
log ""
///////////////////////
NO_VB_TARGET:
free ZAPPA
eval "call {LLA}"
asm P_SEC+29, $RESULT
eval "call {GPA}"
asm P_SEC+36, $RESULT
//---------------------------
mov [P_SEC+48], #B8#
//---------------------------
eval "{SCRIPTNAME} {L2}{LONG} {L1} {L2}Attention! {L1}In some cases the process can crash durring executing this code! {L1}Do you wanna disable LLA & GPA callings? {L1}Press first time >> YES << {L1}Press next time >> NO << if the code has crashed before! {L1}{LINES} \r\n{MY}"
msgyn $RESULT
cmp $RESULT, 00
je RUNO_2
fill P_SEC+26, 19, 90
log ""
log "Calling LLA & GPA was disabled!"
//---------------------------
///////////////////////
RUNO_2:
cmp EX_SEC, 00
jne RUNO_2A
mov esp_hold, esp
pusha
call EXIT_PATCH
///////////////////////
RUNO_2A:
mov eip, P_SEC
bp P_SEC+4F
run
cmp eip, EX_SEC
jne NORMAL_REAL_STOP
log ""
log "Problem Stop!"
///////////////////////
NORMAL_REAL_STOP:
// inc CHECK
// cmp CHECK, 05
// jne RUNO_2
bc
bphwc
mov eip, OEP
mov esp, esp_hold
popa
call RESTORE_EXIT
free P_SEC
log "Found main API Table!"
//--------------------------  New Scan
cmp NEWWAY, 01
jne NEW_ENIGMA_SCAN_HERE
ret
///////////////////////
NEW_ENIGMA_SCAN_HERE:
eval "{SCRIPTNAME} {L2}{LONG} {L1} {L2}Do you wanna let scan for Intern Enigma Functions? {L1}Press >> YES << if your target IAT does use them! {L1}Later you will know which functions are used in the IAT! {L1}{LINES} \r\n{MY}"
msgyn $RESULT
cmp $RESULT, 01
jne NEXT_2
pusha
mov eax, IAT_READ
mov ecx, DIS_COUNT
mov edx, I_COUNT
mul ecx, edx
add ecx, eax
mov REG_TABLE_TOP, ecx
exec
bswap eax
ende
mov edi, eax
and edi,F0000000
cmp edi, 00
jne USE_NORMAL_STRING
mov edi, eax
and edi,FF000000
cmp edi, 00
jne USE_NORMAL_STRING_0
mov edi, eax
and edi,FFF00000
cmp edi, 00
jne USE_NORMAL_STRING_00
msg "Problem with Stringer"
jmp STRINGER_PROBLEM
///////////////////////
USE_NORMAL_STRING_00:
eval "#B800{eax}B9{edx}#"
mov STRINGER, $RESULT
jmp FIND_NORMAL_STRING
///////////////////////
USE_NORMAL_STRING_0:
eval "#B80{eax}B9{edx}#"
mov STRINGER, $RESULT
jmp FIND_NORMAL_STRING
///////////////////////
USE_NORMAL_STRING:
eval "#B8{eax}B9{edx}#"
mov STRINGER, $RESULT
///////////////////////
FIND_NORMAL_STRING:
find ENIGMASEC, STRINGER
cmp $RESULT, 00
jne FOUND_NEAR_REG
///////////////////////
STRINGER_PROBLEM:
popa
eval "{SCRIPTNAME} {L2}{LONG} {L1} {L2}Found nothing! {L1}Problem! {L1}Intern function scan will be disabled now! {L1}Better you tell LCF-AT! {L1}{LINES} \r\n{MY}"
msg $RESULT
log ""
log "Intern function scan will be disabled now!"
log "Better you tell LCF-AT!"
log ""
jmp NEXT_2
pause
pause
pause
ret
///////////////////////
FOUND_NEAR_REG:
mov edi, $RESULT
preop edi
mov edi, $RESULT
///////////////////////
PRE_LOOP:
preop edi
mov edi, $RESULT
cmp [edi], E8, 01 
jne PRE_LOOP
add edi, 05
cmp [edi], B8, 01
je IS_SHORT_MOV
pause
pause
ret
///////////////////////
IS_SHORT_MOV:
mov REGNAME_TABLE, [edi+01]
add edi, 05
cmp [edi], B9, 01
je IS_SHORT_MOV_2
pause
pause
ret
///////////////////////
IS_SHORT_MOV_2:
mov REGNAME_TABLE_COUNT, [edi+01], 01
mov eax, REG_TABLE_TOP
mov ecx, REGNAME_TABLE
mov edx, 00
mov edx, REGNAME_TABLE_COUNT
mov edi, MODULEBASE
eval "{PROCESSNAME_2} - INTERN - Reg Jump Table Functions.txt"
mov sFile3, $RESULT
wrt sFile3, " "
log ""
log "Reg Jump Table Functions"
log "----------------------------------"
var SELF_COUNT
var VA_BAK
///////////////////////
READ_REG_TABLE:
cmp edx, 00
je REG_TABLE_LOG_END
dec edx
gstr [ecx]
mov EN_API,     $RESULT
mov VA, [eax]
mov RVA, [eax]
sub RVA, edi
eval "Jump to Push - API == RVA: {RVA} | VA: {VA} | Func: {EN_API}"
log $RESULT, ""
eval "Jump to Push - API == RVA: {RVA} | VA: {VA} | Func: {EN_API}"
wrta sFile3, $RESULT
cmp SELF_COUNT, 00
je LABEL_IT
cmp VA, VA_BAK
je DONT_LABEL_AGAIN
///////////////////////
LABEL_IT:
lbl VA, EN_API
cmt VA, EN_API
///////////////////////
DONT_LABEL_AGAIN:
mov VA_BAK, VA
mov VA,     00
mov RVA,    00
add eax, 04
add ecx, 04
inc SELF_COUNT
mov EN_API, 00
jmp READ_REG_TABLE
// MACHER
///////////////////////
REG_TABLE_LOG_END:
log "----------------------------------"
log ""
popa
//-------------------------- New Scan End
jmp NEXT_2
///////////////////////
NO_IAT_RD_FOUND:
log "Found no main API Table!"
jmp NEXT_2
///////////////////////
NEXT_2:
cmp IIE_YES, 02
je FOUND_NO_SPECIAL_IAT_RD
find ENIGMASEC, #BF????????BB????????8B35????????803B0074??8B#
cmp $RESULT, 00
je FOUND_NO_SPECIAL_IAT_RD
mov IAT_RD, $RESULT
find IAT_RD, #83C3??4?75#
cmp $RESULT, 00
jne ONE_SIGN_FOUND_S
pause
pause
ret
///////////////////////
ONE_SIGN_FOUND_S:
mov TWO_S, $RESULT
cmp [TWO_S+02], 18 ,01
je IAT_RD_FOUND_SPECIAL
pause
pause
ret
///////////////////////
IAT_RD_FOUND_SPECIAL:
cmp IIE_YES, 01
je ASK_FOR_IAT
cmp IAT, 00
je ASK_FOR_IAT
mov IAT_SIZE,   I_SIZE
mov IAT_SIZE_2, I_SIZE
jmp DIV_SIZE
///////////////////////
ASK_FOR_IAT:
ask "Enter IAT start address"
mov IAT,   $RESULT
mov IAT_2, $RESULT
ask "Enter IAT size"
mov I_SIZE, $RESULT
mov I_SIZE_2, $RESULT
mov IAT_SIZE, $RESULT
mov IAT_SIZE_2, $RESULT
///////////////////////
DIV_SIZE:
div I_SIZE, 04
mov IAT_READ, [IAT_RD+06]
mov I_COUNT,  [IAT_RD+01]
mov OEP, eip
alloc 1000
mov P_SEC, $RESULT
find ENIGMASEC, #609CB201BE00000000#
cmp $RESULT, 00
jne OUTER_FOUND_A
pause
pause
ret
///////////////////////
OUTER_FOUND_A:
mov VM_A, $RESULT
add VM_A, 20
find VM_A, #609CB201BE00000000#
cmp $RESULT, 00
jne OUTER_FOUND_B
pause
pause
ret
///////////////////////
OUTER_FOUND_B:
mov VM_A, $RESULT
alloc 1000
mov LOGSEC,   $RESULT
mov LOGSEC_2, $RESULT
pusha
mov edi, 00
mov esi, 00
mov edi, IAT_READ
mov ebx, I_COUNT
///////////////////////
READ_DATAS:
mov esi, [edi+0C]
cmp [esi], E9, 01
je JUMPER
pause
pause
ret
///////////////////////
JUMPER:
mov eax, esi
mov ecx, esi
add eax, [ecx+01]
add eax, 05
cmp [eax], 68, 01
je PUSHER
pause
pause
ret
///////////////////////
PUSHER:
mov edx, [eax+01]
mov [LOGSEC], edx
mov eax, [edi+08]
mov [LOGSEC+04], eax
add LOGSEC, 08
add edi, 18
dec ebx
cmp ebx, 00
jne READ_DATAS
alloc 1000
mov IN_SEC,   $RESULT
mov IN_SEC_2, $RESULT
mov esi, IAT_2
mov edi, IAT_SIZE_2
mov ebp, ENIGMASEC
///////////////////////
LOOPI:
mov eax, [esi]
gmemi eax, MEMORYBASE
cmp $RESULT, ebp
je LOOPI_IN
jmp ADD_LOOPI
///////////////////////
LOOPI_IN:
mov [IN_SEC], esi  // wo IAT
mov [IN_SEC+04], eax  // VM
add IN_SEC, 08
///////////////////////
ADD_LOOPI:
add esi, 04
sub edi, 04
cmp edi, 00
jne LOOPI
popa
mov espler, esp
///////////////////////
LOOPI_2_START:
cmp [IN_SEC_2], 00
je OVER_2
mov eip, [IN_SEC_2+04]  // VM EIP
bphws VM_A
esto
bphwc
pusha
mov eax, [esp]     // push xy
mov edi, LOGSEC_2  // Push xy and API +4
mov esi, IN_SEC_2
///////////////////////
LOOPI_2:
cmp [edi], 00
je OVER_1
cmp [edi], eax
je FOUND_PUSH
add edi, 08
jmp LOOPI_2
pause
pause
ret
///////////////////////
FOUND_PUSH:
mov eax, [edi+04]  // API
mov ecx, [esi]     // Wo
mov [ecx], eax     // API to IAT
///////////////////////
ADDLER:
popa
add IN_SEC_2, 08
mov esp, espler
jmp LOOPI_2_START
///////////////////////
OVER_1:
mov ENAPI,    [esi]
mov ENAPI_IN, [esi+04]
eval "Possible Enigma API at: {ENAPI} | {ENAPI_IN}"
log $RESULT, ""
jmp ADDLER
///////////////////////
OVER_2:
mov eip, OEP
mov esp, espler
cmp IIE_YES, 00
je FOUND_NO_SPECIAL_IAT_RD
mov IIE_YES, 02
ret
///////////////////////
FOUND_NO_SPECIAL_IAT_RD:
find ENIGMASEC, #609CB201BE00000000#
cmp $RESULT, 00
je NO_VM_ROTINE_FOUND
mov OUTER_VM, $RESULT
log OUTER_VM
pusha
mov eax, OUTER_VM
findop eax, #E8#
mov eax, $RESULT
add eax, 05
findop eax, #E8#
mov eax, $RESULT
add eax, 05
findop eax, #E8#
mov eax, $RESULT
gci eax, DESTINATION
mov OUTER_START, $RESULT
log OUTER_START
mov eax, OUTER_START
findop eax, #A1#
mov VM_WO, [$RESULT+01]
mov VM_WO, [VM_WO]
mov VM_TABLE_OUT, VM_WO
popa
gmemi ENIGMASEC, MEMORYSIZE
mov LASTSEC, $RESULT
add LASTSEC, ENIGMASEC
mov line, 00
eval "JMP 0{OUTER_VM}"
findcmd LASTSEC, $RESULT
///////////////////////
CALC:
mov BAK, 00
gref line
cmp $RESULT, 00
je finished
mov BAK, $RESULT
cmp [BAK-05], 68, 01
je VM_TABLE_START
inc line
jmp CALC
///////////////////////
VM_TABLE_START:
sub BAK, 5
mov JTABLE, BAK
mov $RESULT, JTABLE
jmp GET_INTERN_VM_DATA
///////////////////////
finished:
log "--------------------"
log "Outer VM not used!"
log "--------------------"
jmp END
///////////////////////
GET_INTERN_VM_DATA:
mov JTABLE, $RESULT
add JTABLE, 05
gci JTABLE, DESTINATION
mov LOOP,   $RESULT
sub JTABLE, 05
findop LOOP,#E8#
mov LOOP,   $RESULT
// inc LOOP
add LOOP, 05
find LOOP,  #E8#
mov LOOP,   $RESULT
inc LOOP
find LOOP,  #E8#
mov LOOP,   $RESULT
gci LOOP,   DESTINATION
mov LOOP,   $RESULT
find LOOP, #3D3102000075??#  // 231
cmp $RESULT, 00
jne MODDERN_VM_FOUND
find LOOP,  #83F8??77ED#
cmp $RESULT, 00
je VERSION_OLD
log ""
log "Enigma 1.96 - 3.70 detected"
jmp GET_VM_POINTER
///////////////////////
VERSION_OLD:
log ""
log "Enigma 1.7 - 1.91  detected"
log ""
///////////////////////
GET_VM_POINTER:
pusha
mov eax, OUTER_VM
findop eax, #E8#
mov eax, $RESULT
preop eax
mov eax, $RESULT
preop eax
mov eax, $RESULT
mov ESP_POINTER, [eax+02]
add ESP_POINTER, 04
mov ESP_POINTER_IN, [ESP_POINTER]
popa
find LOOP, #A1??????????04F083C0FD83F8#
cmp $RESULT, 00
jne OLDER_VM_USED
find LOOP, #3D3102000075??#
cmp $RESULT, 00
jne MODDERN_VM_FOUND
///////////////////////
LATEST_VERSION:
log "Found no moddern VM >> cmp eax,231 <<!"
find LOOP, #3D????????75??43????3D????????0F85#  // 1.91
cmp $RESULT, 00
jne OLDER_VM_USED
jmp NO_VM_ROTINE_FOUND
///////////////////////
MODDERN_VM_FOUND:
findop LOOP, #A1#
mov NEW_POINTER, $RESULT
mov NEW_POINTER_IN, [NEW_POINTER+01]
mov NEW_POINTER_IN, [NEW_POINTER_IN]
log ""
mov VM_POINTER_1,    NEW_POINTER_IN
mov VM_POINTER_1_IN, [VM_POINTER_1]
mov VM_POINTER_2,    [VM_POINTER_1]
//-------------
find NEW_POINTER, #8B40?C8B????A1#
cmp $RESULT, 00
jne FOUND_SIGN_A
//---------------------------- NEW
find NEW_POINTER, #8B4??C8B????#
cmp $RESULT, 00
jne FOUND_SIGN_A
//---------------------------- NEW
pause
pause
ret
///////////////////////
FOUND_SIGN_A:
mov LAP, [$RESULT+02], 01
cmp LAP, 6C
je NORMAL_GOON
add VM_POINTER_2, LAP-04
mov VM_POINTER_2_IN, [VM_POINTER_2]
mov VM_POINTER_3,    [VM_POINTER_1]
add VM_POINTER_3, LAP
mov VM_POINTER_3_IN, [VM_POINTER_3]
mov VM_POINTER_4,    [VM_POINTER_1]
add VM_POINTER_4, LAP+04
mov VM_POINTER_4_IN, [VM_POINTER_4]
jmp NORMAL_GOON_OVER
///////////////////////
NORMAL_GOON:
//--------------
add VM_POINTER_2, 68
mov VM_POINTER_2_IN, [VM_POINTER_2]
mov VM_POINTER_3,    [VM_POINTER_1]
add VM_POINTER_3, 6C
mov VM_POINTER_3_IN, [VM_POINTER_3]
mov VM_POINTER_4,    [VM_POINTER_1]
add VM_POINTER_4, 70
mov VM_POINTER_4_IN, [VM_POINTER_4]
///////////////////////
NORMAL_GOON_OVER:
log ""
eval "VM_POINTER_2_IN  : {VM_POINTER_2_IN}  // VM Main Table"
log $RESULT, ""
log ""
mov pointerin, VM_POINTER_2_IN
eval "VM_POINTER_1     : {VM_POINTER_1}"
log $RESULT, ""
eval "VM_POINTER_1_IN  : {VM_POINTER_1_IN} <-- Dump VM"
log $RESULT, ""
eval "VM_POINTER_2     : {VM_POINTER_2}"
log $RESULT, ""
eval "VM_POINTER_2_IN  : {VM_POINTER_2_IN} <-- Dump VM"
log $RESULT, ""
eval "VM_POINTER_3     : {VM_POINTER_3}"
log $RESULT, ""
eval "VM_POINTER_3_IN  : {VM_POINTER_3_IN} <-- Dump VM"
log $RESULT, ""
eval "VM_POINTER_4     : {VM_POINTER_4}"
log $RESULT, ""
eval "VM_POINTER_4_IN  : {VM_POINTER_4_IN} <-- Dump VM"
log $RESULT, ""
pusha
mov eax, OUTER_VM
findop eax, #E8#
mov eax, $RESULT
preop eax
mov eax, $RESULT
preop eax
mov eax, $RESULT
mov ESP_POINTER, [eax+02]
add ESP_POINTER, 04
mov ESP_POINTER_IN, [ESP_POINTER]
mov [ESP_POINTER-04], 00
popa
eval "ESP_POINTER      : {ESP_POINTER}"
log $RESULT, ""
eval "ESP_POINTER_IN   : {ESP_POINTER_IN} <-- Change VM Pointer!"
log $RESULT, ""
log ""
gmi EP, MODULESIZE
mov MODULESIZE, $RESULT
add BASE_AND_SIZE, MODULESIZE
add BASE_AND_SIZE, MODULEBASE
pusha
mov eax, 00
mov ecx, 00
mov edx, 00
mov ebx, 00
mov edi, 00
mov eax, VM_POINTER_1_IN
mov ecx, VM_POINTER_2_IN
mov edx, VM_POINTER_3_IN
mov ebx, VM_POINTER_4_IN
////////////////////////////
IN_1:
gmemi eax, MEMORYBASE
mov eax,   $RESULT
gmemi ecx, MEMORYBASE
mov ecx,   $RESULT
gmemi edx, MEMORYBASE
mov edx,   $RESULT
gmemi ebx, MEMORYBASE
mov ebx,   $RESULT
////////////////////////////
CHECK_1:
inc VM_COUNT
cmp eax, 00
je CHECK_2
mov edi, eax
cmp eax, BASE_AND_SIZE
ja DUMP
cmp eax, MODULEBASE
jb OUTSIDE_1
log "VM Part is inside!"
jmp CHECK_2
////////////////////////////
OUTSIDE_1:
log "VM Part is above of PE!!!"
mov OUT, 01
jmp DUMP
pause
pause
ret
////////////////////////////
CHECK_2:
inc VM_COUNT
cmp ecx, 00
je CHECK_3
mov edi, ecx
cmp ecx, BASE_AND_SIZE
ja DUMP
cmp ecx, MODULEBASE
jb OUTSIDE_2
log "VM Part is inside!"
jmp CHECK_3
////////////////////////////
OUTSIDE_2:
log "VM Part is above of PE!!!"
mov OUT, 01
jmp DUMP
pause
pause
ret
////////////////////////////
CHECK_3:
inc VM_COUNT
cmp edx, 00
je CHECK_4
mov edi, edx
cmp edx, BASE_AND_SIZE
ja DUMP
cmp edx, MODULEBASE
jb OUTSIDE_3
log "VM Part is inside!"
jmp CHECK_4
////////////////////////////
OUTSIDE_3:
log "VM Part is above of PE!!!"
mov OUT, 01
jmp DUMP
pause
pause
ret
////////////////////////////
CHECK_4:
inc VM_COUNT
cmp ebx, 00
je CHECK_5
mov edi, ebx
cmp ebx, BASE_AND_SIZE
ja DUMP
cmp ebx, MODULEBASE
jb OUTSIDE_4
log "VM Part is inside!"
jmp CHECK_5
////////////////////////////
OUTSIDE_4:
log ""
log "VM Part is above of PE!!!"
mov OUT, 01
jmp DUMP
log "Dump VM manually and adjust VM Pointers later!"
eval "{SCRIPTNAME} {L2}{LONG} {L1} {L2}VM Part is above of PE!!! {L1}Dump VM manually and adjust VM Pointers later! {L1}{LINES} \r\n{MY}"
msg $RESULT
pause
pause
ret
////////////////////////////
CHECK_5:
log ""
log "All VM was dumped!Add them with the right RVA and rebuid PE before fixing!"
log "Dont forget to change the ESP Pointer manually in your dumped file!"
popa
jmp DUMPING_DISABLED
////////////////////////////
DUMP:
gmemi edi, MEMORYSIZE
mov esi, $RESULT
mov ebp, edi
cmp OUT, 01
je ADJUST_DUMP
sub ebp, MODULEBASE
////////////////////////////
ADJUST_DUMP:
cmp DUMP_OUTER_VM, 01
jne NO_DUMPS
cmp OUT, 00
je NO_ADJUST_DUMP
eval "VM - VA_{edi}_RVA_ADJUST_size_{esi}.mem"
dm edi, esi, $RESULT
eval "VM - VA_{edi}_RVA_ADJUST_size_{esi}.mem"
log $RESULT, ""
log "VM was dumped!"
log "Fix VM Pointer manually later!"
mov OUT, 00
jmp NO_DUMPS
////////////////////////////
NO_ADJUST_DUMP:
eval "VM - VA_{edi}_RVA_{ebp}_size_{esi}.mem"
dm edi, esi, $RESULT
eval "VM - VA_{edi}_RVA_{ebp}_size_{esi}.mem"
log $RESULT, ""
log "VM was dumped!"
mov OUT, 00
////////////////////////////
NO_DUMPS:
mov edi, 00
mov esi, 00
mov ebp, 00
cmp VM_COUNT, 01
je CHECK_2
cmp VM_COUNT, 02
je CHECK_3
cmp VM_COUNT, 03
je CHECK_4
cmp VM_COUNT, 04
je CHECK_5
pause
pause
ret
///////////////////////
DUMPING_DISABLED:
log ""
log "Enigma 3.70 - 3.130 detected"
jmp LOG_POINTER_2
///////////////////////
OLDER_VM_USED:
findop LOOP, #A1#
cmp $RESULT, 00
jne FOUND_FIRST
pause
pause
ret
///////////////////////
FOUND_FIRST:
mov NEW_POINTER, $RESULT
mov NEW_POINTER_IN, [NEW_POINTER+01]
mov NEW_POINTER_IN, [NEW_POINTER_IN]
// mov NEW_POINTER_IN, [NEW_POINTER_IN]
log ""
pusha
gmemi NEW_POINTER_IN, MEMORYBASE
mov edx, $RESULT
cmp edx, MODULEBASE
ja ALL_FINE
log "VM section address is lower than target PE!"
log "You have to adjust the addresses manually!"
mov MANUALLY, 01
///////////////////////
ALL_FINE:
gmemi NEW_POINTER_IN, MEMORYSIZE
mov eax, $RESULT
mov ecx, edx
cmp MANUALLY, 01
jne NORMALDUMP_VA
cmp DUMP_OUTER_VM, 01
jne NO_DUMPS5
eval "VM - VA_{edx}_RVA_ADJUST_size_{eax}.mem"
dm edx, eax, $RESULT
eval "VM - VA_{edx}_RVA_ADJUST_size_{eax}.mem"
log $RESULT, ""
log "VM was dumped!"
///////////////////////
NO_DUMPS5:
popa
jmp ESP_POINTER_NOT_FOUND
///////////////////////
NORMALDUMP_VA:
sub ecx, MODULEBASE
cmp DUMP_OUTER_VM, 01
jne NO_DUMPS6
eval "VM - VA_{edx}_RVA_{ecx}_size_{eax}.mem"
dm edx, eax, $RESULT
eval "VM - VA_{edx}_RVA_{ecx}_size_{eax}.mem"
log $RESULT, ""
log "VM was dumped!"
///////////////////////
NO_DUMPS6:
popa
jmp ESP_POINTER_NOT_FOUND
///////////////////////
ESP_POINTER_NOT_FOUND:
add LOOP, 30
find LOOP, #A1????????8B#
cmp $RESULT, 00
jne LOG_POINTER
pause
pause
ret
///////////////////////
LOG_POINTER:
mov pointer,    $RESULT
mov pointerin, [pointer+01]
mov VM_POINTER_1, [pointer+01]
mov pointerin, [pointerin]
mov VM_POINTER_1_IN, pointerin
mov [ESP_POINTER-04], 00
log ""
eval "VM_POINTER_1     : {VM_POINTER_1}"
log $RESULT, ""
eval "VM_POINTER_1_IN  : {VM_POINTER_1_IN}"
log $RESULT, ""
eval "ESP_POINTER      : {ESP_POINTER}"
log $RESULT, ""
eval "ESP_POINTER_IN   : {ESP_POINTER_IN}"
log $RESULT, ""
cmp DUMP_OUTER_VM, 00
je DUMPING_DISABLED_2
pusha
mov eax, VM_POINTER_1_IN
mov ecx, 00
gmemi eax, MEMORYBASE
mov ecx, $RESULT
gmemi ecx, MEMORYSIZE
mov edx, $RESULT
xchg eax, edx
xchg ecx, edx
mov ecx, edx
sub ecx, MODULEBASE
cmp DUMP_OUTER_VM, 01
jne NO_DUMPS7
cmp MANUALLY, 01
jne NORMALDUMP_VA2
eval "VM - VA_{edx}_RVA_ADJUST_size_{eax}.mem"
dm edx, eax, $RESULT
eval "VM - VA_{edx}_RVA_ADJUST_size_{eax}.mem"
log $RESULT, ""
log "VM was dumped!"
jmp NO_DUMPS7
///////////////////////
NORMALDUMP_VA2:
eval "VM - VA_{edx}_RVA_{ecx}_size_{eax}.mem"
dm edx, eax, $RESULT
eval "VM - VA_{edx}_RVA_{ecx}_size_{eax}.mem"
log $RESULT, ""
log "VM was dumped!"
///////////////////////
NO_DUMPS7:
popa
log ""
log ""
log "Dump and add needed VM and change pointers if needed!"
///////////////////////
DUMPING_DISABLED_2:
log ""
///////////////////////
LOG_POINTER_2:
log ""
log "---------- VM DATA ----------"
log ""
log JTABLE, "JUMP TABLE AT: "
log pointerin, "VM TABLE AT:   "
log LASTSEC, "LASTSEC:       "
log ""
log JTABLE, ""
log pointerin, ""
log LASTSEC, ""
log "-----------------------------"
jmp END
///////////////////////
NO_VM_ROTINE_FOUND:
log "Found no VM routine!"
jmp END
///////////////////////
END:
cmp TLS, 00
je NO_TLS
cmp TLS_CB_IN, 00
je NO_TLS
mov [TLS_CB], 00
log "TLS callback was killed!"
///////////////////////
NO_TLS:
call OLDER_VM_CHECKING
bc
bphwc
log ""
log "Script Finished - See Olly LOG for more infos!"
log ""
log "For VM fixing you can use my other script til version 3.70!"
log ""
log "Thank you and bye bye"
eval "{SCRIPTNAME} {L2}{LONG} {L1} {L2}Script Finished - See Olly LOG for more infos! {L1}For VM fixing you can use my other script til version 3.70! {L1}Thank you and bye bye! {L1}{LINES} \r\n{MY}"
msg $RESULT
pause
ret
///////////////////////
VARS:
cmp $VERSION, "1.82"
je FIRST_RUN
ja FIRST_RUN
eval "{SCRIPTNAME} {L2}{LONG} {L1} {L2}Update your ODBG-Script plugin!!! {L1}{LINES} \r\n{MY}"
msg $RESULT
ret
///////////////////////
FIRST_RUN:
bphwc
bc
bpmc
var IIE_YES
var WHAS
var FILEALIG
var TESTNAME
var TESTNAMELENGHT
var IS_EIP_NAME
var TESTI
var REALNAME
var TLS_WO
var POS_MEMIAT
var NEXTSECTION
var PID
var TEMP_SEC
var EP
var LECKER
var API_INTO
var ZAPPA
var NAPPA
var ThunRTMain
var ENIGMASEC
var IAT_TABLE_1
var POS_MEMSIZE
var NEWWAY
var Temp
var Var1
var Var2
var CATCH_1
var CATCH_2
var NEW_TABLE_STYLE
var OUT
var SCAN_DUMP_OVR
var GetModuleHandleA
var GetProcAddress
var GetProcAddress_RET
var VirtualAlloc
var VirtualQuery
var VirtualProtectEx
var HWID
var HWID_WO
var HWID_IS_SET
var PRE_CHECKER
var PRE_CHECKER_PATCH
var HWID_PATCH
var COUNTER
var VirtualQuery_BAK
var IAT
var IAT_2
var IAT_RD
var TWO_S
var I_SIZE
var IAT_READ
var I_COUNT
var P_SEC
var CHECK
var LLA
var GPA
var CodeBase
var CodeSize
var HWID_EASY_BYPASS
var REG1
var REG2
var REG1_COM
var REG2_COM
var CRC_PATCH
var CRC_1
var CRC_2
var OUTER_VM
var OUTER_START
var VM_WO
var VM_TABLE_OUT
var BAK
var JTABLE
var LOOP
var esp_hold
var EX_SEC
var NEW_POINTER
var NEW_POINTER_IN
var pointerin
var pointer
var MODULEBASE
var ENTRY
var IMAGESIZE
var TLS
var TLS_CB
var TLS_CB_IN
var VMOEP
var VMOEPBAK
var tmp
var tmp2
var MAK_LOW
var PATH
var CURRENTDIR
var CURRENTDIR_LENGHT
var TARGET_NAME
var SECTIONS
var LASTSEC
var PE_START
var IS_ENIGMA
var V1
var V2
var ANTI_PLUG
var MJ
var QUICK
var QUICK_PATCHED
var CODESECTION
var ENDSEC
var I_SIZE_2
var VM_A
var LOGSEC
var LOGSEC_2
var IN_SEC
var IN_SEC_2
var espler
var ENAPI
var ENAPI_IN
var MODULESIZE
var BASE_AND_SIZE
var VM_COUNT
var MANUALLY
var ESP_OLD
var CODEBAK
var ESP_ADDR
var PUSH_AD
var stop
var PUSH_RET
var stop2
var CHECKUP
var VM_LOG_SEC
var VM_LOG_SEC_2
var VM_PATTERNSEC
var VM_PATTERNSEC_2
var A
var VirtualProtect_RET
var ROUNDA
var addr
var size
var store
var B
var in
var EXP_NAME_VA_SEC
var EXP_NAME_VA_SEC_2
var VirtualProtect
var VM_POINTER_1
var VM_POINTER_1_IN
var VM_POINTER_2
var VM_POINTER_2_IN
var VM_POINTER_3
var VM_POINTER_3_IN
var ESP_POINTER
var ESP_POINTER_IN
var DUMP_OUTER_VM
var SCRIPTNAME
var MY
var LONG
var L1
var L2
var LINES
var PROCESSNAME
var PROCESSNAME_2
var READ_DLL_LOADER
var GET_EP_VM_VALUES
var ret
var EAXA
var WHERE
var sFile
var sFile1
var sFile2
var sFile3
var EN_FIRSTSEC
var EN_FIRSTSEC_2
var EXPORT
var DLL_NAME
var counta
var RVA
var ExitProcess
var ExitProcess_BAK
var VA
var DLL_PE
var EN_API
var IN_VMER
var ESP_IS
var CHECK_ME
var EXPORT_IS
var PUSH_IS
var INT_VERSION
var ESV
var EXEFILENAME
var CURRENTDIR_COUNT
var OVERSEC
var OVERSEC_2
var LAYER
var CreateFileA
var GetFileSize
var SetFilePointer
var ReadFile
var CloseHandle
var WriteFile
var EIP_BAK
var DeleteFileA
var TARGET_SIZE
var TARGET_SIZE_2
var OVERLAY_SIZE
var OVERLAY_DUMPED
var OVERLAY_SIZE_DEC
var OVERLAY_NAME
var OVERLAY_SCAN
var OVERDUMP
var DPSEC
var FreeLibrary
var TITAN
GPI PROCESSNAME
mov PROCESSNAME,   $RESULT
mov PROCESSNAME_2, $RESULT
mov LONG, "-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+"
mov LINES, "********************"
mov L1, "\r\n\r\n"
mov L2, "\r\n"
mov SCRIPTNAME, "Enigma Alternativ Unpacker 1.1"
mov MY, "LCF-AT"
mov EP, eip
log SCRIPTNAME, ""
log LONG, ""
log ""
gpa "CreateFileA",      "kernel32.dll"
mov CreateFileA,         $RESULT
gpa "GetFileSize",      "kernel32.dll"
mov GetFileSize,         $RESULT
gpa "SetFilePointer",   "kernel32.dll"
mov SetFilePointer,      $RESULT
gpa "ReadFile",         "kernel32.dll"
mov ReadFile,            $RESULT
gpa "CloseHandle",      "kernel32.dll"
mov CloseHandle,         $RESULT
gpa "WriteFile",        "kernel32.dll"
mov WriteFile,           $RESULT
gpa "DeleteFileA",       "kernel32.dll"
mov DeleteFileA,         $RESULT
gpa "FreeLibrary",      "kernel32.dll"
mov FreeLibrary,         $RESULT
gpa "GetModuleHandleA", "kernel32.dll"
mov  GetModuleHandleA,   $RESULT
gpa "GetProcAddress",   "kernel32.dll"
mov  GetProcAddress,     $RESULT
gpa "VirtualProtect",   "kernel32.dll"
mov VirtualProtect,      $RESULT
find VirtualProtect,     #C21000#
mov VirtualProtect_RET,  $RESULT
gpa "VirtualProtectEx", "kernel32.dll"
mov VirtualProtectEx,    $RESULT
gpa "VirtualQuery",     "kernel32.dll"
mov VirtualQuery,        $RESULT
gpa "VirtualAlloc",     "kernel32.dll"
mov VirtualAlloc,        $RESULT
gpa "LoadLibraryA",     "kernel32.dll"
mov LLA,                 $RESULT
gpa "GetProcAddress",   "kernel32.dll"
mov GPA,                 $RESULT
gpa "ExitProcess",      "kernel32.dll"
mov ExitProcess,         $RESULT
readstr [ExitProcess], 05
mov ExitProcess_BAK, $RESULT
buf ExitProcess_BAK
ret
///////////////////////
EXIT_PATCH:
alloc 1000
mov EX_SEC, $RESULT
fill EX_SEC, 20, 90
mov [EX_SEC], #EBFE#
eval "jmp 0{EX_SEC}"
asm ExitProcess, $RESULT
bphws EX_SEC
ret
///////////////////////
RESTORE_EXIT:
mov [ExitProcess], ExitProcess_BAK
free EX_SEC
ret
///////////////////////
EXIT_PATCH_2:
alloc 1000
mov EX_SEC, $RESULT
fill EX_SEC, 20, 90
mov [EX_SEC], #EBFE#
eval "jmp 0{EX_SEC}"
asm ExitProcess, $RESULT
ret
///////////////////////
OLDER_VM_CHECKING:
mov CODEBAK, CODESECTION
mov ESP_ADDR, esp
mov BAK, eip
find ENIGMASEC, #9C60FF742424E8????????89442424619DC3#
cmp $RESULT, 00
jne FOUND_STOLEN_CODE
log ""
log "FOUND NO STOLEN CODE M1"
ret
///////////////////////
FOUND_STOLEN_CODE:
mov PUSH_AD, $RESULT
mov stop, $RESULT
mov PUSH_RET, $RESULT+11
mov stop2, $RESULT+11
call EXIT_PATCH_2
find stop2, #E8????????84C00F84????????8B??????????8B3F#
cmp $RESULT, 00
jne FOUND_CHECKUPER
find stop2, #E8????????84C00F84????????A1????????8B??8B????????04#
cmp $RESULT, 00
jne FOUND_CHECKUPER
jmp NO_WRITING
///////////////////////
FOUND_CHECKUPER:
mov CHECKUP, $RESULT
gci CHECKUP, DESTINATION
mov CHECKUP, $RESULT
mov [CHECKUP], #B801000000C3#
log "CHECKUP was found and patched!"
///////////////////////
NO_WRITING:
alloc 10000
mov VM_LOG_SEC,      $RESULT
mov VM_LOG_SEC_2,    $RESULT
alloc 11000
mov VM_PATTERNSEC,   $RESULT
mov VM_PATTERNSEC_2, $RESULT
///////////////////////
SUCH:
find CODEBAK, #68????????E9#
cmp $RESULT, 00
je NO_MORE_OLD_VM_JUMP
mov A, $RESULT
mov CODEBAK, $RESULT
add CODEBAK, 5
mov eip, $RESULT
add eip, 5
gci eip, DESTINATION
cmp $RESULT, stop
jne SUCH
sub eip, 5
bp stop2
bp VirtualProtect_RET
run
cmp eip, VirtualProtect_RET
jne T1_VM
cmp ROUNDA, 01
je SEF1
mov addr, [esp+4]
mov size, [esp+8]
mov [VM_LOG_SEC],    addr
mov [VM_LOG_SEC+04], size
add VM_LOG_SEC, 08
///////////////////////
SEF1:
bc VirtualProtect_RET
run
cmp ROUNDA, 01
je SET_ROUNDER
readstr [addr], size
mov store, $RESULT
buf store
mov [VM_PATTERNSEC], store
add VM_PATTERNSEC, size
mov ROUNDA, 01
///////////////////////
T1_VM:
call STO_LOOP
cmp eip, stop2
je T1_VM
mov B, eip
cmp [eip], 68, 01
je 1_VM
///////////////////////
1_VM:
cmp [eip+05], E9, 01
je 2_VM
///////////////////////
2_VM:
fill A, 5, 90
eval "jmp {B}"
asm A, $RESULT
readstr [A], 5
mov in, $RESULT
buf in
jmp SUCH
///////////////////////
SET_ROUNDER:
mov ROUNDA, 00
jmp T1_VM
///////////////////////
NO_MORE_OLD_VM_JUMP:
cmp VM_LOG_SEC_2, VM_LOG_SEC
je NO_CODE_TO_RESTORE
pusha
mov eax, VM_LOG_SEC_2
mov ebx, VM_LOG_SEC
mov esi, VM_PATTERNSEC_2
///////////////////////
RESTORE_CODE:
cmp eax, ebx
je RESTORE_END
mov edi, [eax]
mov ecx, [eax+04]
exec
REP MOVS BYTE PTR ES:[EDI],BYTE PTR DS:[ESI]
ende
add eax, 08
jmp RESTORE_CODE
///////////////////////
RESTORE_END:
bc
popa
log ""
log "Stolen Code M1 was fixed!"
log ""
mov eip, BAK
free VM_PATTERNSEC_2
free VM_LOG_SEC
mov esp, ESP_ADDR
call RESTORE_EXIT
ret
///////////////////////
NO_CODE_TO_RESTORE:
mov eip, BAK
free VM_PATTERNSEC_2
free VM_LOG_SEC
log ""
log "Stolen Code M1 nothing to fix!"
log ""
call RESTORE_EXIT
ret
///////////////////////
STO_LOOP:
mov bak ,eip
///////////////////////
STO_LOOP_DO:
sto
cmp eip, bak
je STO_LOOP_DO
mov bak, 00
ret
///////////////////////
STI_LOOP:
mov bak ,eip
///////////////////////
STI_LOOP_DO:
sti
cmp eip, bak
je STI_LOOP_DO
mov bak, 00
ret
///////////////////////
EXPORT_VM_CHECK:
cmp READ_DLL_LOADER, 00
jne EXPORT_VM_CHECK_ENABLED
log ""
log "Export Scan & Log Disabled by User!"
ret
///////////////////////
EXPORT_VM_CHECK_ENABLED:
mov DLL_PE, ENIGMASEC
pusha
mov esi, 00
mov edi, 00
mov eax, DLL_PE
mov ecx, [eax+3C]
add ecx, eax
mov esi, [ecx+78]
mov edi, [ecx+7C]
cmp esi, 00
je NO_EXPORTS_FOUND
mov DLL_IMAGE, [ecx+50]
mov EXPORT, esi
add EXPORT, eax
mov ebp, [EXPORT+0C]+eax
mov ebx, ebp
///////////////////////
NAME_LOOP:
gstr ebx
mov DLL_NAME, $RESULT
cmp DLL_NAME, 00
jne DLL_NAME_IN
mov DLL_NAME, "DLL_Loader.dll"
///////////////////////
DLL_NAME_IN:
log "----------------------------------"
log DLL_NAME, ""
log "----------------------------------------------------------------------"
mov ecx, esi+eax
mov edx, [ecx+14]
mov ebx, [ecx+18]     
mov ebp, [ecx+1C]+eax 
mov edi, [ecx+20]+eax 
mov esi, [ecx+24]+eax 
mov counta, 00
mov edx, counta
mov eax, edx
eval "{PROCESSNAME_2} - {DLL_NAME} - Functions.txt"
mov sFile, $RESULT
wrt sFile, " "
eval "{PROCESSNAME_2} - {DLL_NAME} - Breakpoint & Comment Functions.txt"
mov sFile1, $RESULT
wrt sFile1, " "
alloc 2000
mov EN_FIRSTSEC,   $RESULT
mov EN_FIRSTSEC_2, $RESULT
mov [EN_FIRSTSEC], DLL_NAME
add EN_FIRSTSEC, 100
alloc 4000
mov EXP_NAME_VA_SEC,   $RESULT
mov EXP_NAME_VA_SEC_2, $RESULT
///////////////////////
START_READ_EXPORTS:
mov eax, edx
exec
mov ax,word ptr ds:[esi+eax*2]
mov eax, edx
MOVZX EAX,WORD PTR DS:[ESI+EAX*2]
MOV EAX,DWORD PTR DS:[EBP+EAX*4]
ende
mov [EN_FIRSTSEC], eax
add EN_FIRSTSEC, 04
mov RVA, eax
add eax, DLL_PE
mov VA, eax
mov eax, edx
exec
MOV EAX,DWORD PTR DS:[EDI+EAX*4]
ende
add eax, DLL_PE
inc counta
inc edx
mov EN_API, eax
mov [EXP_NAME_VA_SEC], eax
add EXP_NAME_VA_SEC, 04
jmp NAME_CALC
///////////////////////
NAME_CALC:
gstr EN_API
mov EN_API, $RESULT
cmp EN_API, "EP_EnigmaVersion"
jne NAME_CALC_NEXT
mov INT_VERSION, VA
///////////////////////
NAME_CALC_NEXT:
eval "RVA: {RVA} | VA: {VA} | Func: {EN_API}"
log $RESULT, ""
eval "RVA: {RVA} | VA: {VA} | Func: {EN_API}"
wrta sFile, $RESULT
eval "cmt {VA},"{EN_API}""
wrta sFile1, $RESULT
eval "bp {VA}"
wrta sFile1, $RESULT
lbl VA, EN_API
cmt VA, EN_API
cmp edx, ebx
je DLL_END_READ
jmp START_READ_EXPORTS
///////////////////////
DLL_END_READ:
popa
log "----------------------------------------------------------------------"
log ""
log ""
cmp GET_EP_VM_VALUES, 00
je EP_VM_SCAN_DISABLED
call READ_PUSH_VALUES
ret
///////////////////////
EP_VM_SCAN_DISABLED:
log ""
log "EP Export VM Scan Disabled by User!"
ret
///////////////////////
NO_EXPORTS_FOUND:
popa
log "Found no exports in Enigma Loader!"
ret
///////////////////////
READ_PUSH_VALUES:
call STO_LOOP
find eip, #FFE0#
cmp $RESULT, 00
je CALL_EAX
mov EAXA, $RESULT
jmp SET_R32
///////////////////////
CALL_EAX:
find eip, #FFD0#
cmp $RESULT, 00
jne FOUND_CALL_EAX
///////////////////////
FOUND_CALL_EAX:
mov EAXA, $RESULT
jmp SET_R32
///////////////////////
SET_R32:
bphws EAXA
esto
bphwc EAXA
call STI_LOOP
find eip, #C20C00#
cmp $RESULT, 00
jne RET_FOUND
find eip, #E8????????E8#
cmp $RESULT, 00
jne RET_FOUND
pause
pause
ret
///////////////////////
RET_FOUND:
mov ret, $RESULT
bphws ret, "x"
esto
bphwc ret
cmp GET_EP_VM_VALUES, 01
je GO_ON_HERE
ret
///////////////////////
GO_ON_HERE:
mov BAK, eip
find ENIGMASEC, #609CB201BE00000000#
cmp $RESULT, 00
je OUTER_NOT_THERE
mov IN_VMER, $RESULT
add IN_VMER, 10
find IN_VMER, #609CB201BE00000000#
cmp $RESULT, 00
jne INTTER_TWO_FOUND
jmp INNER_NOT_THERE
///////////////////////
INTTER_TWO_FOUND:
mov IN_VMER, $RESULT
mov ESP_IS, esp
mov CHECK_ME, EN_FIRSTSEC_2+100
eval "{PROCESSNAME_2} - {DLL_NAME} - Addresses - Functions - VM Values.txt"
mov sFile2, $RESULT
wrt sFile2, " "
log "----------------------------------------------------------------------"
///////////////////////
READ_PUSH_VALUES_IN:
cmp [CHECK_ME], 00
je EXPORT_OVER
mov eip, ENIGMASEC+[CHECK_ME]
cmp [eip], E9, 01
je IS_A_JUMPER
cmp [eip], #8D6424FC#, 04
je GET_VALUES
cmp [eip], 68 , 01
je VM_PUSH_DIRECT
cmp [eip], E8 , 01
je IS_A_JUMPER
///////////////////////
CRYPT:
mov PUSH_IS, "DeCrypt_"
jmp FILL_INFO
///////////////////////
VM_PUSH_DIRECT:
mov WHERE, eip
gci eip, SIZE
cmp $RESULT, 05
je VM_PUSH
mov PUSH_IS, "DeCrypt_"
jmp FILL_INFO
///////////////////////
IS_A_JUMPER:
gci eip, DESTINATION
cmp $RESULT, 00
jne JUMP_DESTI
mov PUSH_IS, "DeCrypt_"
jmp FILL_INFO
///////////////////////
JUMP_DESTI:
mov WHERE, $RESULT
cmp [WHERE], 68, 01
je VM_PUSH
cmp [WHERE], E9 , 01
je ANOTHER_JUMP
gci WHERE, DESTINATION
cmp $RESULT, 00
jne JUMP_DESTI
jmp CRYPT
///////////////////////
ANOTHER_JUMP:
mov eip, WHERE
jmp IS_A_JUMPER
///////////////////////
VM_PUSH:
mov PUSH_IS, [WHERE+01]
///////////////////////
FILL_INFO:
mov eip, ENIGMASEC+[CHECK_ME]
jmp LOG_FILES_B
///////////////////////
GET_VALUES:
bphws IN_VMER
esto
mov PUSH_IS, [esp]
///////////////////////
LOG_FILES:
mov RVA, [CHECK_ME]
mov VA, RVA+ENIGMASEC
///////////////////////
LOG_FILES_B:
mov RVA, [CHECK_ME]
mov VA, RVA+ENIGMASEC
gstr [EXP_NAME_VA_SEC_2]
mov EXPORT_IS, $RESULT
cmp PUSH_IS, "DeCrypt_"
je WHAT_IN_8
itoa PUSH_IS
mov PUSH_IS, $RESULT
len PUSH_IS
mov WHAS, $RESULT
eval "WHAT_IN_{WHAS}"
jmp $RESULT
pause
pause
ret
///////////////////////
WHAT_IN_1:
call PUSH_ATOI
eval "RVA: {RVA} | VA: {VA} | VM PUSH VALUE: 0000000{PUSH_IS} | Func: {EXPORT_IS}"
log $RESULT, ""
eval "RVA: {RVA} | VA: {VA} | VM PUSH VALUE: 0000000{PUSH_IS} | Func: {EXPORT_IS}"
wrta sFile2, $RESULT
jmp NEXT_END
///////////////////////
WHAT_IN_2:
call PUSH_ATOI
eval "RVA: {RVA} | VA: {VA} | VM PUSH VALUE: 000000{PUSH_IS} | Func: {EXPORT_IS}"
log $RESULT, ""
eval "RVA: {RVA} | VA: {VA} | VM PUSH VALUE: 000000{PUSH_IS} | Func: {EXPORT_IS}"
wrta sFile2, $RESULT
jmp NEXT_END
///////////////////////
WHAT_IN_3:
call PUSH_ATOI
eval "RVA: {RVA} | VA: {VA} | VM PUSH VALUE: 00000{PUSH_IS} | Func: {EXPORT_IS}"
log $RESULT, ""
eval "RVA: {RVA} | VA: {VA} | VM PUSH VALUE: 00000{PUSH_IS} | Func: {EXPORT_IS}"
wrta sFile2, $RESULT
jmp NEXT_END
///////////////////////
WHAT_IN_4:
call PUSH_ATOI
eval "RVA: {RVA} | VA: {VA} | VM PUSH VALUE: 0000{PUSH_IS} | Func: {EXPORT_IS}"
log $RESULT, ""
eval "RVA: {RVA} | VA: {VA} | VM PUSH VALUE: 0000{PUSH_IS} | Func: {EXPORT_IS}"
wrta sFile2, $RESULT
jmp NEXT_END
///////////////////////
WHAT_IN_5:
call PUSH_ATOI
eval "RVA: {RVA} | VA: {VA} | VM PUSH VALUE: 000{PUSH_IS} | Func: {EXPORT_IS}"
log $RESULT, ""
eval "RVA: {RVA} | VA: {VA} | VM PUSH VALUE: 000{PUSH_IS} | Func: {EXPORT_IS}"
wrta sFile2, $RESULT
jmp NEXT_END
///////////////////////
WHAT_IN_6:
call PUSH_ATOI
eval "RVA: {RVA} | VA: {VA} | VM PUSH VALUE: 00{PUSH_IS} | Func: {EXPORT_IS}"
log $RESULT, ""
eval "RVA: {RVA} | VA: {VA} | VM PUSH VALUE: 00{PUSH_IS} | Func: {EXPORT_IS}"
wrta sFile2, $RESULT
jmp NEXT_END
///////////////////////
WHAT_IN_7:
call PUSH_ATOI
eval "RVA: {RVA} | VA: {VA} | VM PUSH VALUE: 0{PUSH_IS} | Func: {EXPORT_IS}"
log $RESULT, ""
eval "RVA: {RVA} | VA: {VA} | VM PUSH VALUE: 0{PUSH_IS} | Func: {EXPORT_IS}"
wrta sFile2, $RESULT
jmp NEXT_END
///////////////////////
WHAT_IN_8:
cmp PUSH_IS, "DeCrypt_"
jne NO_LINES
log "----------------------------------------------------------------------"
eval "RVA: {RVA} | VA: {VA} | VM PUSH VALUE: {PUSH_IS} | Func: {EXPORT_IS}"
log $RESULT, ""
log "----------------------------------------------------------------------"
wrta sFile2, "----------------------------------------------------------------------"
eval "RVA: {RVA} | VA: {VA} | VM PUSH VALUE: {PUSH_IS} | Func: {EXPORT_IS}"
wrta sFile2, $RESULT
wrta sFile2, "----------------------------------------------------------------------"
jmp NEXT_END
///////////////////////
NO_LINES:
call PUSH_ATOI
eval "RVA: {RVA} | VA: {VA} | VM PUSH VALUE: {PUSH_IS} | Func: {EXPORT_IS}"
log $RESULT, ""
eval "RVA: {RVA} | VA: {VA} | VM PUSH VALUE: {PUSH_IS} | Func: {EXPORT_IS}"
wrta sFile2, $RESULT
///////////////////////
NEXT_END:
add CHECK_ME, 04
add EXP_NAME_VA_SEC_2, 04
mov esp, ESP_IS
mov EXPORT_IS, 00
mov PUSH_IS,   00
mov WHERE,     00
mov WHAS,      00
jmp READ_PUSH_VALUES_IN
///////////////////////
EXPORT_OVER:
log "----------------------------------------------------------------------"
log ""
log "All Exports Functions - Addresses - VM Values logged!"
free EXP_NAME_VA_SEC
free EN_FIRSTSEC
ret
///////////////////////
INNER_NOT_THERE:
log ""
log "Found no Inner VM Routine!"
free EXP_NAME_VA_SEC
free EN_FIRSTSEC
ret
///////////////////////
OUTER_NOT_THERE:
log ""
log "Found no Outer VM Routine!"
free EXP_NAME_VA_SEC
free EN_FIRSTSEC
ret
///////////////////////
PUSH_ATOI:
atoi PUSH_IS
mov PUSH_IS, $RESULT
ret
///////////////////////
SCAN_DUMP_OVERLAY:
gpi EXEFILENAME
mov EXEFILENAME, $RESULT
gpi CURRENTDIR
mov CURRENTDIR, $RESULT
len CURRENTDIR
mov CURRENTDIR_COUNT, $RESULT
alloc 4000
mov OVERSEC, $RESULT
mov OVERSEC_2, $RESULT+1000
alloc 10000
mov LAYER, $RESULT
mov [OVERSEC], EXEFILENAME
mov [OVERSEC_2], #60BFAAAAAAAA8BEF81C5000700006A006A006A036A006A0168000000808BC750E8859A6CAA8BD883FBFF0F84AA0100008987000500006A0053E86C9A6CAA8BF06A006A006A036A006A0168000000808BC750E8539A6CAA8BD883FBFF0F846D0100008987040500006A006A006A0053E8369A6CAA6A008D45F8506A408D45B85053E8249A6CAA837DF8400F853F0100006A006A008B45F45053E80C9A6CAA6A008D45F85068F80000008D85C0FEFFFF5053E8F4996CAA817DF8F80000000F850C0100006A006A008B45F405F80000000FB795C6FEFFFF4AC1E2038D149203C25053E8C4996CAA6A008D45F8506A288D8598FEFFFF5053E8AF996CAA8B85ACFEFFFF0385A8FEFFFF89870805000089B70C0500003BF00F84B40000006A006A005053E884996CAA8B870C0500002B8708050000898710050000B8BBBBBB0B8945EC6A008D45F450FFB7100500008B45EC5053E854996CAA53E84E996CAA6A006A006A026A006A026800000040803F000F840600000047E9F1FFFFFFC7072E4F5652BFAAAAAAAA57E81F996CAA8BD883FBFF0F84390000008987140500006A006A006A0053E802996CAA6A008D45F0508B8710050000508B45EC5053E8EB986CAA53E8E5986CAAC7871805000001000000FFB704050000E8D0986CAAFFB700050000E8C5986CAA6190909090#
mov [OVERSEC_2+02], OVERSEC
mov [OVERSEC_2+139], LAYER
mov [OVERSEC_2+181], OVERSEC
eval "call {CreateFileA}"
asm OVERSEC_2+20, $RESULT
eval "call {GetFileSize}"
asm OVERSEC_2+39, $RESULT
eval "call {CreateFileA}"
asm OVERSEC_2+52, $RESULT
eval "call {SetFilePointer}"
asm OVERSEC_2+6F, $RESULT
eval "call {ReadFile}"
asm OVERSEC_2+81, $RESULT
eval "call {SetFilePointer}"
asm OVERSEC_2+99, $RESULT
eval "call {ReadFile}"
asm OVERSEC_2+0B1, $RESULT
eval "call {SetFilePointer}"
asm OVERSEC_2+0E1, $RESULT
eval "call {ReadFile}"
asm OVERSEC_2+0F6, $RESULT
eval "call {SetFilePointer}"
asm OVERSEC_2+121, $RESULT
eval "call {ReadFile}"
asm OVERSEC_2+151, $RESULT
eval "call {CloseHandle}"
asm OVERSEC_2+157, $RESULT
eval "call {CreateFileA}"
asm OVERSEC_2+186, $RESULT
eval "call {SetFilePointer}"
asm OVERSEC_2+1A3, $RESULT
eval "call {WriteFile}"
asm OVERSEC_2+1BA, $RESULT
eval "call {CloseHandle}"
asm OVERSEC_2+1C0, $RESULT
eval "call {CloseHandle}"
asm OVERSEC_2+1D5, $RESULT
eval "call {CloseHandle}"
asm OVERSEC_2+1E0, $RESULT
mov EIP_BAK, eip
mov eip, OVERSEC_2
mov [OVERSEC_2+1E5], #9057E8BE986CAA6190#
eval "call {DeleteFileA}"
asm OVERSEC_2+1E7, $RESULT
bp OVERSEC_2+1ED
run
bc
mov TARGET_SIZE,    [OVERSEC+508]
mov TARGET_SIZE_2,  [OVERSEC+50C]
mov OVERLAY_SIZE,   [OVERSEC+510]
mov OVERLAY_DUMPED, [OVERSEC+518]
itoa OVERLAY_SIZE, 10.
mov OVERLAY_SIZE_DEC, $RESULT
pusha
mov eax, OVERSEC
add eax, CURRENTDIR_COUNT
gstr eax
mov OVERLAY_NAME, $RESULT
popa
mov OVERLAY_SCAN, "Yes"
mov OVERDUMP, 01
cmp OVERLAY_DUMPED, 01
je OVERLAY_LOG
mov OVERDUMP, 00
mov OVERLAY_NAME, 00
mov OVERLAY_DUMPED, "No Overlay Found!"
mov OVERLAY_SCAN, "No"
////////////////////
OVERLAY_LOG:
log ""
log "---------- OVERLAY ---------------"
log ""
eval "Overlay Found: {OVERLAY_DUMPED}"
log $RESULT, ""
eval "Overlay NAME : {OVERLAY_NAME}"
log $RESULT, ""
eval "Overlay SIZE : {OVERLAY_SIZE} Hex"
log $RESULT, ""
eval "Overlay SIZE : {OVERLAY_SIZE_DEC} Dec"
log $RESULT, ""
log "----------------------------------"
log ""
cmp OVERDUMP, 01
jne OVER_EXIT
fill OVERSEC, 4000, 00
mov [OVERSEC], EXEFILENAME
eval "{EXEFILENAME}.OVR"
mov [OVERSEC+2000], $RESULT
alloc 2000
mov DPSEC, $RESULT
mov [DPSEC+1000], TITAN
mov [DPSEC], #60B800000000BEAAAAAAAABFAAAAAAAA68AAAAAAAAE890AAFDA909C0741A57568BC88BE833C081C120940000FFD109C07403EB079061EB0361909055E869AAFDA909C074F661909090#
mov [DPSEC+07], OVERSEC
mov [DPSEC+0C], OVERSEC+2000
mov [DPSEC+11], DPSEC+1000
eval "call {LoadLibraryA}"
asm DPSEC+15, $RESULT
eval "call {FreeLibrary}"
asm DPSEC+3C, $RESULT
bp DPSEC+39
bp DPSEC+36
bp DPSEC+46
mov eip, DPSEC
run
cmp eip, DPSEC+46
je ALL_VERY_FINE
cmp eip, DPSEC+36
je NO_OVR_DUMPED
////////////////////
DLL_WAS_NOT_LOADED:
log ""
log "Titan was not loaded!"
log "Use a other overlay extract tool later!"
log ""
msg "Titan was not loaded! \r\n\r\nUse a other overlay extract tool later! \r\n\r\nLCF-AT"
bc
jmp ALL_VERY_FINE
////////////////////
NO_OVR_DUMPED:
log ""
log "Overlay was not dumped correctly!"
log "Use a other overlay extract tool later!"
log ""
msg "Overlay was not dumped correctly! \r\n\r\nUse a other overlay extract tool later! \r\n\r\nLCF-AT"
bc eip
run
bc
jmp ALL_VERY_FINE
////////////////////
ALL_VERY_FINE:
bc
mov eip, EIP_BAK
free DPSEC
////////////////////
OVER_EXIT:
mov eip, EIP_BAK
free OVERSEC
free LAYER
ret
////////////////////
ENTER_YOUR_TITAN_PATH:
eval "{SCRIPTNAME} {L2}{LONG} {L1} {L2}Hey you lazy little cracker! {L1}I told you to enter your TITAN.dll path on the script top! {L1}Enter your path and save and then the script will also start! {L1}Man man man man man du!Dir muss man auch alles 100 mal sagen was! {L1}Jetzt komm aus'm Quark und mach voran du Ei! {L1}{LINES} \r\n{MY}"
msg $RESULT
ret
////////////////////
CHECK_TITAN:
alloc 1000
mov LECKER, $RESULT
mov [LECKER], TITAN
pusha
mov edi, LECKER
exec
push edi
call {LoadLibraryA}
ende
cmp eax, 00
je NO_TITAN_LOADED
exec
push eax
call {FreeLibrary}
ende
popa
free LECKER
log ""
log "Titan.dll loading check was successfully!"
log "Na,das hast du aber fein gemacht ;)"
log ""
ret
////////////////////
NO_TITAN_LOADED:
popa
free LECKER
eval "{SCRIPTNAME} {L2}{LONG} {L1} {L2}Hey again you lazy little cracker! {L1}I told you already to enter your >> RIGHT <<  TITAN.dll path on the script top! {L1}Enter your path and save and then the script will also start! {L1}Man man man man man du!Dir muss man auch alles 500 mal sagen was! {L1}Jetzt komm aus'm Quark und mach voran du Fuzzy! {L1}{LINES} \r\n{MY}"
msg $RESULT
ret